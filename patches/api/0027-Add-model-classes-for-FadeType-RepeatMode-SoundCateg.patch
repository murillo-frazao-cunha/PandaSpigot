From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: murillo <murillofrazaocunha@gmail.com>
Date: Thu, 17 Jul 2025 23:12:48 -0300
Subject: [PATCH] Add model classes for FadeType, RepeatMode, SoundCategory,
 and Note; deprecate old implementations


diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/CompatibilityUtils.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/CompatibilityUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..b5155018958d2a89acb45c3898d46e3d312e7490
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/CompatibilityUtils.java
@@ -0,0 +1,143 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Sound;
+import org.bukkit.entity.Player;
+
+import java.util.ArrayList;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils}
+ */
+@Deprecated
+public class CompatibilityUtils {
+
+	public static final String OBC_DIR = Bukkit.getServer().getClass().getPackage().getName();
+	public static final String NMS_DIR = OBC_DIR.replaceFirst("org.bukkit.craftbukkit", "net.minecraft.server");
+
+	/**
+	 * Gets NMS class from given name
+	 * @param name of class (w/ package)
+	 * @return Class of given name
+	 */
+	public static Class<?> getMinecraftClass(String name) {
+		return com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.getMinecraftClass(name);
+	}
+
+	/**
+	 * Gets CraftBukkit class from given name
+	 * @param name of class (w/ package)
+	 * @return Class of given name
+	 */
+	public static Class<?> getCraftBukkitClass(String name) {
+		return com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.getCraftBukkitClass(name);
+	}
+
+	/**
+	 * Returns whether the version of Bukkit is or is after 1.12
+	 * @return version is after 1.12
+	 */
+	public static boolean isPost1_12() {
+		return com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.isPost1_12();
+	}
+
+	/**
+	 * Returns if SoundCategory is able to be used
+	 * @see SoundCategory
+	 * @return can use SoundCategory
+	 */
+	protected static boolean isSoundCategoryCompatible() {
+		return com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.getServerVersion() >= 0.0111f;
+	}
+
+	/**
+	 * Plays a sound using NMS and reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 */
+	public static void playSound(Player player, Location location, String sound, 
+			SoundCategory category, float volume, float pitch) {
+		com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.playSound(player, location, sound, com.xxmicloxx.NoteBlockAPI.model.SoundCategory.valueOf(category.name()), volume, pitch);
+	}
+
+	/**
+	 * Plays a sound using NMS and reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 */
+	public static void playSound(Player player, Location location, Sound sound, 
+			SoundCategory category, float volume, float pitch) {
+		com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.playSound(player, location, sound, com.xxmicloxx.NoteBlockAPI.model.SoundCategory.valueOf(category.name()), volume, pitch);
+	}
+
+	/**
+	 * Gets instruments which were added post-1.12
+	 * @return ArrayList of instruments
+	 * @deprecated Use {@link #getVersionCustomInstruments(float)}
+	 */
+	public static ArrayList<CustomInstrument> get1_12Instruments(){
+		return getVersionCustomInstruments(0.0112f);
+	}
+
+	/**
+	 * Return list of instuments which were added in specified version
+	 * @param serverVersion 1.12 = 0.0112f, 1.14 = 0.0114f,...
+	 * @return list of custom instruments, if no instuments were added in specified version returns empty list
+	 */
+	public static ArrayList<CustomInstrument> getVersionCustomInstruments(float serverVersion){
+		ArrayList<CustomInstrument> instruments = new ArrayList<>();
+		if (serverVersion == 0.0112f){
+			instruments.add(new CustomInstrument((byte) 0, "Guitar", "guitar.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Flute", "flute.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Bell", "bell.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Chime", "icechime.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Xylophone", "xylobone.ogg"));
+			return instruments;
+		}
+
+		if (serverVersion == 0.0114f){
+			instruments.add(new CustomInstrument((byte) 0, "Iron Xylophone", "iron_xylophone.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Cow Bell", "cow_bell.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Didgeridoo", "didgeridoo.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Bit", "bit.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Banjo", "banjo.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Pling", "pling.ogg"));
+			return instruments;
+		}
+		return instruments;
+	}
+
+	/**
+	 * Return list of custom instruments based on song first custom instrument index and server version
+	 * @param firstCustomInstrumentIndex
+	 * @return
+	 */
+	public static ArrayList<CustomInstrument> getVersionCustomInstrumentsForSong(int firstCustomInstrumentIndex){
+		ArrayList<CustomInstrument> instruments = new ArrayList<>();
+
+		if (com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.getServerVersion() < 0.0112f){
+			if (firstCustomInstrumentIndex == 10) {
+				instruments.addAll(getVersionCustomInstruments(0.0112f));
+			} else if (firstCustomInstrumentIndex == 16){
+				instruments.addAll(getVersionCustomInstruments(0.0112f));
+				instruments.addAll(getVersionCustomInstruments(0.0114f));
+			}
+		} else if (com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.getServerVersion() < 0.0114f){
+			if (firstCustomInstrumentIndex == 16){
+				instruments.addAll(getVersionCustomInstruments(0.0114f));
+			}
+		}
+
+		return instruments;
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/CustomInstrument.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/CustomInstrument.java
new file mode 100644
index 0000000000000000000000000000000000000000..5d050c1b4900f86f79c53c516e3f9f1c0e9b8565
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/CustomInstrument.java
@@ -0,0 +1,63 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.model.Sound;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.model.CustomInstrument}
+ */
+@Deprecated
+public class CustomInstrument{
+	
+	private byte index;
+	private String name;
+	private String soundFileName;
+	private org.bukkit.Sound sound;
+
+	/**
+	 * Creates a CustomInstrument
+	 * @param index
+	 * @param name
+	 * @param soundFileName
+	 */
+	public CustomInstrument(byte index, String name, String soundFileName) {
+		this.index = index;
+		this.name = name;
+		this.soundFileName = soundFileName.replaceAll(".ogg", "");
+		if (this.soundFileName.equalsIgnoreCase("pling")){
+			this.sound = Sound.NOTE_PLING.bukkitSound();
+		}
+	}
+
+	/**
+	 * Gets index of CustomInstrument
+	 * @return index
+	 */
+	public byte getIndex() {
+		return index;
+	}
+
+	/**
+	 * Gets name of CustomInstrument
+	 * @return name
+	 */
+	public String getName() {
+		return name;
+	}
+	
+	/**
+	 * Gets the org.bukkit.Sound enum for this CustomInstrument
+	 * @return org.bukkit.Sound enum
+	 */
+	public org.bukkit.Sound getSound() {
+		return sound;
+	}
+	
+	/**
+	 * Gets file name of the sound
+	 * @deprecated misleading name.
+	 */
+	public String getSoundfile() {
+		return soundFileName;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/FadeType.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/FadeType.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab0a06339f7ac654268e2ee1b9f80b55342eb9fb
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/FadeType.java
@@ -0,0 +1,11 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.model.FadeType}
+ */
+@Deprecated
+public enum FadeType {
+
+	FADE_LINEAR
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/Instrument.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/Instrument.java
new file mode 100644
index 0000000000000000000000000000000000000000..f90d2a4d467e6a8f79e759ddd5ee446356c3c3da
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/Instrument.java
@@ -0,0 +1,59 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.model.Sound;
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+
+/**
+ * @deprecated {@link InstrumentUtils}
+ */
+@Deprecated
+public class Instrument {
+
+	/**
+	 * Returns the org.bukkit.Sound enum for the current server version
+	 * @param instrument
+	 * @see Sound
+	 * @return Sound enum (for the current server version)
+	 */
+	public static org.bukkit.Sound getInstrument(byte instrument) {
+		return org.bukkit.Sound.valueOf(getInstrumentName(instrument));
+	}
+
+	/**
+	 * Returns the name of the org.bukkit.Sound enum for the current server version
+	 * @param instrument
+	 * @see Sound
+	 * @return Sound enum name (for the current server version)
+	 */
+	public static String getInstrumentName(byte instrument) {
+		return InstrumentUtils.getInstrumentName(instrument);
+}
+
+	/**
+	 * Returns the name of the org.bukkit.Instrument enum for the current server version
+	 * @param instrument
+	 * @return Instrument enum (for the current server version)
+	 */
+	public static org.bukkit.Instrument getBukkitInstrument(byte instrument) {
+		return InstrumentUtils.getBukkitInstrument(instrument);
+	}
+
+	/**
+	 * If true, the byte given represents a custom instrument
+	 * @param instrument
+	 * @return whether the byte represents a custom instrument
+	 */
+	public static boolean isCustomInstrument(byte instrument) {
+		return InstrumentUtils.isCustomInstrument(instrument);
+	}
+
+	/**
+	 * Gets the first index in which a custom instrument 
+	 * can be added to the existing list of instruments
+	 * @return index where an instrument can be added
+	 */
+	public static byte getCustomInstrumentFirstIndex() {
+		return InstrumentUtils.getCustomInstrumentFirstIndex();
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/Interpolator.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/Interpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..1988c6f97e0dc327bd3099a8ffaf85425011ed7a
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/Interpolator.java
@@ -0,0 +1,35 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+/**
+ * <p>Static methods for doing useful math</p><hr>
+ *
+ * @author : $Author: brian $
+ * @version : $Revision: 1.1 $
+ *          <hr><p><a href="http://www.mbari.org">
+ *          The Monterey Bay Aquarium Research Institute (MBARI)</a> provides this
+ *          documentation and code &quot;as is&quot;, with no warranty, express or
+ *          implied, of its quality or consistency. It is provided without support and
+ *          without obligation on the part of MBARI to assist in its use, correction,
+ *          modification, or enhancement. This information should not be published or
+ *          distributed to third parties without specific written permission from
+ *          MBARI.</p><br>
+ *          Copyright 2002 MBARI.<br>
+ *          MBARI Proprietary Information. All rights reserved.<br><hr><br>
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.utils.Interpolator}
+ */
+@Deprecated
+public class Interpolator {
+
+	public static double[] interpLinear(double[] x, double[] y, double[] xi) throws IllegalArgumentException {
+		return com.xxmicloxx.NoteBlockAPI.utils.Interpolator.interpLinear(x, y, xi);
+	}
+
+	public static double[] interpLinear(long[] x, double[] y, long[] xi) throws IllegalArgumentException {
+		return com.xxmicloxx.NoteBlockAPI.utils.Interpolator.interpLinear(x, y, xi);
+	}
+
+	public static double interpLinear(double[] xy, double xx) {
+		return com.xxmicloxx.NoteBlockAPI.utils.Interpolator.interpLinear(xy, xx);
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/Layer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/Layer.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ce12af96d20e473f4094e4e415a543d1d8b2ccf
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/Layer.java
@@ -0,0 +1,78 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import java.util.HashMap;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.model.Layer}
+ */
+@Deprecated
+public class Layer{
+
+	private HashMap<Integer, Note> notesAtTicks = new HashMap<Integer, Note>();
+	private byte volume = 100;
+	private String name = "";
+
+	/**
+	 * Gets the name of the Layer
+	 */
+	public String getName() {
+		return name;
+	}
+
+	/**
+	 * Sets the name of the Layer
+	 */
+	public void setName(String name) {
+		this.name = name;
+	}
+
+	/**
+	 * Gets the note played at a given tick
+	 */
+	public Note getNote(int tick) {
+		return notesAtTicks.get(tick);
+	}
+
+	/**
+	 * Sets the given note at the given tick in the Layer
+	 */
+	public void setNote(int tick, Note note) {
+		notesAtTicks.put(tick, note);
+	}
+
+	/**
+	 * Gets the volume of all notes in the Layer
+	 * @return byte representing the volume
+	 */
+	public byte getVolume() {
+		return volume;
+	}
+
+	/**
+	 * Sets the volume for all notes in the Layer
+	 * @param volume
+	 */
+	public void setVolume(byte volume) {
+		this.volume = volume;
+	}
+	
+	/**
+	 * Gets the notes in the Layer with the tick they are created as a hash map. 
+	 * @return HashMap of notes with the tick they are played at
+	 * @deprecated Method name is vague
+	 */
+	@Deprecated
+	public HashMap<Integer, Note> getHashMap() {
+		return notesAtTicks;
+	}
+	
+	/**
+	 * Sets the notes in the Layer with the tick they are created as a hash map
+	 * @deprecated Method name is vague
+	 */
+	@Deprecated
+	public void setHashMap(HashMap<Integer, Note> hashMap) {
+		this.notesAtTicks = hashMap;
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/NBSDecoder.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/NBSDecoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b299d510f29630692236621b516c44912ec5c19
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/NBSDecoder.java
@@ -0,0 +1,224 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.utils.NBSDecoder}
+ */
+@Deprecated
+public class NBSDecoder {
+
+	/**
+	 * Parses a Song from a Note Block Studio project file (.nbs)
+	 * @see Song
+	 * @param songFile .nbs file
+	 * @return Song object representing a Note Block Studio project
+	 */
+	public static Song parse(File songFile) {
+		try {
+			return parse(new FileInputStream(songFile), songFile);
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	/**
+	 * Parses a Song from an InputStream
+	 * @see Song
+	 * @param inputStream of a Note Block Studio project file (.nbs)
+	 * @return Song object from the InputStream
+	 */
+	public static Song parse(InputStream inputStream) {
+		return parse(inputStream, null); // Source is unknown -> no file
+	}
+
+	/**
+	 * Parses a Song from an InputStream and a Note Block Studio project file (.nbs)
+	 * @see Song
+	 * @param inputStream of a .nbs file
+	 * @param songFile representing a .nbs file
+	 * @return Song object representing the given .nbs file
+	 */
+	private static Song parse(InputStream inputStream, File songFile) {
+		HashMap<Integer, Layer> layerHashMap = new HashMap<Integer, Layer>();
+		byte biggestInstrumentIndex = -1;
+		try {
+			DataInputStream dataInputStream = new DataInputStream(inputStream);
+			short length = readShort(dataInputStream);
+			int firstcustominstrument = 10; //Backward compatibility - most of songs with old structure are from 1.12
+			int firstcustominstrumentdiff;
+			int nbsversion = 0;
+			if (length == 0) {
+				nbsversion = dataInputStream.readByte();
+				firstcustominstrument = dataInputStream.readByte();
+				if (nbsversion >= 3) {
+					length = readShort(dataInputStream);
+				}
+			}
+			firstcustominstrumentdiff = InstrumentUtils.getCustomInstrumentFirstIndex() - firstcustominstrument;
+			short songHeight = readShort(dataInputStream);
+			String title = readString(dataInputStream);
+			String author = readString(dataInputStream);
+			readString(dataInputStream); // original author
+			String description = readString(dataInputStream);
+			float speed = readShort(dataInputStream) / 100f;
+			dataInputStream.readBoolean(); // auto-save
+			dataInputStream.readByte(); // auto-save duration
+			dataInputStream.readByte(); // x/4ths, time signature
+			readInt(dataInputStream); // minutes spent on project
+			readInt(dataInputStream); // left clicks (why?)
+			readInt(dataInputStream); // right clicks (why?)
+			readInt(dataInputStream); // blocks added
+			readInt(dataInputStream); // blocks removed
+			readString(dataInputStream); // .mid/.schematic file name
+			if (nbsversion >= 4) {
+				dataInputStream.readByte(); // loop on/off
+				dataInputStream.readByte(); // max loop count
+				readShort(dataInputStream); // loop start tick
+			}
+			short tick = -1;
+			while (true) {
+				short jumpTicks = readShort(dataInputStream); // jumps till next tick
+				//System.out.println("Jumps to next tick: " + jumpTicks);
+				if (jumpTicks == 0) {
+					break;
+				}
+				tick += jumpTicks;
+				//System.out.println("Tick: " + tick);
+				short layer = -1;
+				while (true) {
+					short jumpLayers = readShort(dataInputStream); // jumps till next layer
+					if (jumpLayers == 0) {
+						break;
+					}
+					layer += jumpLayers;
+					//System.out.println("Layer: " + layer);
+					byte instrument = dataInputStream.readByte();
+
+					if (firstcustominstrumentdiff > 0 && instrument >= firstcustominstrument){
+						instrument += firstcustominstrumentdiff;
+					}
+
+					byte key = dataInputStream.readByte();
+
+					if (nbsversion >= 4) {
+						dataInputStream.readByte(); // note block velocity
+						dataInputStream.readByte(); // note block panning
+						readShort(dataInputStream); // note block pitch
+					}
+
+					setNote(layer, tick, instrument /* instrument */,
+							key/* note */, layerHashMap);
+				}
+			}
+
+			if (nbsversion > 0 && nbsversion < 3) {
+				length = tick;
+			}
+
+			for (int i = 0; i < songHeight; i++) {
+				Layer layer = layerHashMap.get(i);
+
+				String name = readString(dataInputStream);
+				if (nbsversion >= 4){
+					dataInputStream.readByte(); // layer lock
+				}
+
+				byte volume = dataInputStream.readByte();
+				if (nbsversion >= 2){
+					dataInputStream.readByte(); // layer stereo
+				}
+				if (layer != null) {
+					layer.setName(name);
+					layer.setVolume(volume);
+				}
+			}
+			//count of custom instruments
+			byte customAmnt = dataInputStream.readByte();
+			CustomInstrument[] customInstrumentsArray = new CustomInstrument[customAmnt];
+
+			for (int index = 0; index < customAmnt; index++) {
+				customInstrumentsArray[index] = new CustomInstrument((byte) index,
+						readString(dataInputStream), readString(dataInputStream));
+				dataInputStream.readByte();//pitch
+				dataInputStream.readByte();//key
+			}
+
+			if (firstcustominstrumentdiff < 0){
+				ArrayList<CustomInstrument> customInstruments = CompatibilityUtils.getVersionCustomInstrumentsForSong(firstcustominstrument);
+				customInstruments.addAll(Arrays.asList(customInstrumentsArray));
+				customInstrumentsArray = customInstruments.toArray(customInstrumentsArray);
+			} else {
+				firstcustominstrument += firstcustominstrumentdiff;
+			}
+
+			return new Song(speed, layerHashMap, songHeight, length, title,
+					author, description, songFile, firstcustominstrument, customInstrumentsArray);
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} catch (EOFException e) {
+			String file = "";
+			if (songFile != null) {
+				file = songFile.getName();
+			}
+			Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.RED + "Song is corrupted: " + file);
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	/**
+	 * Sets a note at a tick in a song
+	 * @param layerIndex
+	 * @param ticks
+	 * @param instrument
+	 * @param key
+	 * @param layerHashMap
+	 */
+	private static void setNote(int layerIndex, int ticks, byte instrument,
+								byte key, HashMap<Integer, Layer> layerHashMap) {
+		Layer layer = layerHashMap.get(layerIndex);
+		if (layer == null) {
+			layer = new Layer();
+			layerHashMap.put(layerIndex, layer);
+		}
+		layer.setNote(ticks, new Note(instrument, key));
+	}
+
+	private static short readShort(DataInputStream dataInputStream) throws IOException {
+		int byte1 = dataInputStream.readUnsignedByte();
+		int byte2 = dataInputStream.readUnsignedByte();
+		return (short) (byte1 + (byte2 << 8));
+	}
+
+	private static int readInt(DataInputStream dataInputStream) throws IOException {
+		int byte1 = dataInputStream.readUnsignedByte();
+		int byte2 = dataInputStream.readUnsignedByte();
+		int byte3 = dataInputStream.readUnsignedByte();
+		int byte4 = dataInputStream.readUnsignedByte();
+		return (byte1 + (byte2 << 8) + (byte3 << 16) + (byte4 << 24));
+	}
+
+	private static String readString(DataInputStream dataInputStream) throws IOException {
+		int length = readInt(dataInputStream);
+		StringBuilder builder = new StringBuilder(length);
+		for (; length > 0; --length) {
+			char c = (char) dataInputStream.readByte();
+			if (c == (char) 0x0D) {
+				c = ' ';
+			}
+			builder.append(c);
+		}
+		return builder.toString();
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/Note.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/Note.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c4d87dd48eb046ca0d345a5be3026ab49f11797
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/Note.java
@@ -0,0 +1,33 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.model.Note}
+ */
+@Deprecated
+public class Note {
+
+	private byte instrument;
+	private byte key;
+
+	public Note(byte instrument, byte key) {
+		this.instrument = instrument;
+		this.key = key;
+	}
+
+	public byte getInstrument() {
+		return instrument;
+	}
+
+	public void setInstrument(byte instrument) {
+		this.instrument = instrument;
+	}
+
+	public byte getKey() {
+		return key;
+	}
+
+	public void setKey(byte key) {
+		this.key = key;
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockAPI.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockAPI.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a34e790363ea9027aa28d9ad54cf2cecab7c6c7
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockAPI.java
@@ -0,0 +1,187 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Main class; contains methods for playing and adjusting songs for players
+ */
+public class NoteBlockAPI  {
+
+    public NoteBlockAPI() {
+        plugin = this;
+        new NoteBlockPlayerMain().onEnable();
+    }
+
+	private static NoteBlockAPI plugin;
+	
+	private Map<UUID, ArrayList<SongPlayer>> playingSongs = new ConcurrentHashMap<UUID, ArrayList<SongPlayer>>();
+	private Map<UUID, Byte> playerVolume = new ConcurrentHashMap<UUID, Byte>();
+
+	private boolean disabling = false;
+	
+	private HashMap<Plugin, Boolean> dependentPlugins = new HashMap<>();
+
+	/**
+	 * Returns true if a Player is currently receiving a song
+	 * @param player
+	 * @return is receiving a song
+	 */
+	public static boolean isReceivingSong(Player player) {
+		return isReceivingSong(player.getUniqueId());
+	}
+
+	/**
+	 * Returns true if a Player with specified UUID is currently receiving a song
+	 * @param uuid
+	 * @return is receiving a song
+	 */
+	public static boolean isReceivingSong(UUID uuid) {
+		ArrayList<SongPlayer> songs = plugin.playingSongs.get(uuid);
+		return (songs != null && !songs.isEmpty());
+	}
+
+	/**
+	 * Stops the song for a Player
+	 * @param player
+	 */
+	public static void stopPlaying(Player player) {
+		stopPlaying(player.getUniqueId());
+	}
+
+	/**
+	 * Stops the song for a Player
+	 * @param uuid
+	 */
+	public static void stopPlaying(UUID uuid) {
+		ArrayList<SongPlayer> songs = plugin.playingSongs.get(uuid);
+		if (songs == null) {
+			return;
+		}
+		for (SongPlayer songPlayer : songs) {
+			songPlayer.removePlayer(uuid);
+		}
+	}
+
+	/**
+	 * Sets the volume for a given Player
+	 * @param player
+	 * @param volume
+	 */
+	public static void setPlayerVolume(Player player, byte volume) {
+		setPlayerVolume(player.getUniqueId(), volume);
+	}
+
+	/**
+	 * Sets the volume for a given Player
+	 * @param uuid
+	 * @param volume
+	 */
+	public static void setPlayerVolume(UUID uuid, byte volume) {
+		plugin.playerVolume.put(uuid, volume);
+	}
+
+	/**
+	 * Gets the volume for a given Player
+	 * @param player
+	 * @return volume (byte)
+	 */
+	public static byte getPlayerVolume(Player player) {
+		return getPlayerVolume(player.getUniqueId());
+	}
+
+	/**
+	 * Gets the volume for a given Player
+	 * @param uuid
+	 * @return volume (byte)
+	 */
+	public static byte getPlayerVolume(UUID uuid) {
+		Byte byteObj = plugin.playerVolume.get(uuid);
+		if (byteObj == null) {
+			byteObj = 100;
+			plugin.playerVolume.put(uuid, byteObj);
+		}
+		return byteObj;
+	}
+	
+	public static ArrayList<SongPlayer> getSongPlayersByPlayer(Player player){
+		return getSongPlayersByPlayer(player.getUniqueId());
+	}
+	
+	public static ArrayList<SongPlayer> getSongPlayersByPlayer(UUID player){
+		return plugin.playingSongs.get(player);
+	}
+	
+	public static void setSongPlayersByPlayer(Player player, ArrayList<SongPlayer> songs){
+		setSongPlayersByPlayer(player.getUniqueId(), songs);
+	}
+	
+	public static void setSongPlayersByPlayer(UUID player, ArrayList<SongPlayer> songs){
+		plugin.playingSongs.put(player, songs);
+	}
+
+
+	public void doSync(Runnable runnable) {
+        Plugin anyPlugin = Bukkit.getServer().getPluginManager().getPlugins()[0];
+		Bukkit.getServer().getScheduler().runTask(anyPlugin, runnable);
+	}
+
+	public void doAsync(Runnable runnable) {
+        Plugin anyPlugin = Bukkit.getServer().getPluginManager().getPlugins()[0];
+        Bukkit.getServer().getScheduler().runTaskAsynchronously(anyPlugin, runnable);
+	}
+
+	public boolean isDisabling() {
+		return disabling;
+	}
+	
+	public static NoteBlockAPI getAPI(){
+		return plugin;
+	}
+	
+	protected void handleDeprecated(StackTraceElement[] ste){
+		int pom = 1;
+		String clazz = ste[pom].getClassName();
+		while (clazz.startsWith("com.xxmicloxx.NoteBlockAPI")){
+			pom++;
+			clazz = ste[pom].getClassName();
+		}
+		String[] packageParts = clazz.split("\\.");
+		ArrayList<Plugin> plugins = new ArrayList<Plugin>();
+		plugins.addAll(dependentPlugins.keySet());
+		
+		ArrayList<Plugin> notResult = new ArrayList<Plugin>();
+		parts:
+		for (int i = 0; i < packageParts.length - 1; i++){
+			
+			for (Plugin pl : plugins){
+				if (notResult.contains(pl)){ continue;}
+				if (plugins.size() - notResult.size() == 1){
+					break parts;
+				}
+				String[] plParts = pl.getDescription().getMain().split("\\.");
+				if (!packageParts[i].equalsIgnoreCase(plParts[i])){
+					notResult.add(pl);
+					continue;
+				}
+			}
+			plugins.removeAll(notResult);
+			notResult.clear();
+		}
+		
+		plugins.removeAll(notResult);
+		notResult.clear();
+		if (plugins.size() == 1){
+			dependentPlugins.put(plugins.get(0), true);
+		}
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockPlayerMain.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockPlayerMain.java
new file mode 100644
index 0000000000000000000000000000000000000000..de3fdb82e1714391056bcd96a5746773eca97c89
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockPlayerMain.java
@@ -0,0 +1,95 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @deprecated {@link NoteBlockAPI}
+ */
+@Deprecated
+public class NoteBlockPlayerMain {
+
+	public static NoteBlockPlayerMain plugin;
+
+	public Map<String, ArrayList<SongPlayer>> playingSongs = 
+			Collections.synchronizedMap(new HashMap<String, ArrayList<SongPlayer>>());
+	public Map<String, Byte> playerVolume = Collections.synchronizedMap(new HashMap<String, Byte>());
+
+	private boolean disabling = false;
+
+	/**
+	 * Returns true if a Player is currently receiving a song
+	 * @param player
+	 * @return is receiving a song
+	 */
+	public static boolean isReceivingSong(Player player) {
+		return ((plugin.playingSongs.get(player.getUniqueId()) != null) 
+				&& (!plugin.playingSongs.get(player.getUniqueId()).isEmpty()));
+	}
+
+	/**
+	 * Stops the song for a Player
+	 * @param player
+	 */
+	public static void stopPlaying(Player player) {
+		if (plugin.playingSongs.get(player.getUniqueId()) == null) {
+			return;
+		}
+		for (SongPlayer songPlayer : plugin.playingSongs.get(player.getUniqueId())) {
+			songPlayer.removePlayer(player);
+		}
+	}
+
+	/**
+	 * Sets the volume for a given Player
+	 * @param player
+	 * @param volume
+	 */
+	public static void setPlayerVolume(Player player, byte volume) {
+		plugin.playerVolume.put(player.getName(), volume);
+		NoteBlockAPI.setPlayerVolume(player, volume);
+	}
+
+	/**
+	 * Gets the volume for a given Player
+	 * @param player
+	 * @return volume (byte)
+	 */
+	public static byte getPlayerVolume(Player player) {
+		Byte byteObj = plugin.playerVolume.get(player.getName());
+		if (byteObj == null) {
+			byteObj = 100;
+			plugin.playerVolume.put(player.getName(), byteObj);
+		}
+		return byteObj;
+	}
+	
+	public void onEnable() {
+		plugin = this;
+	}
+	
+	public void onDisable() {    	
+		disabling = true;
+	}
+
+	public void doSync(Runnable runnable) {
+        Plugin anyPlugin = Bukkit.getServer().getPluginManager().getPlugins()[0];
+		Bukkit.getServer().getScheduler().runTask(anyPlugin, runnable);
+	}
+
+	public void doAsync(Runnable runnable) {
+        Plugin anyPlugin = Bukkit.getServer().getPluginManager().getPlugins()[0];
+		Bukkit.getServer().getScheduler().runTaskAsynchronously(anyPlugin, runnable);
+	}
+
+	public boolean isDisabling() {
+		return disabling;
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockSongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockSongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..d26db61cc5ccec57bc18f897e0b4df8e870ebd52
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/NoteBlockSongPlayer.java
@@ -0,0 +1,141 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Player;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.songplayer.NoteBlockSongPlayer}
+ */
+@Deprecated
+public class NoteBlockSongPlayer extends SongPlayer {
+
+	private Block noteBlock;
+	private int distance = 16;
+
+	public NoteBlockSongPlayer(Song song) {
+		super(song);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.songplayer.NoteBlockSongPlayer.class);
+	}
+
+	public NoteBlockSongPlayer(Song song, SoundCategory soundCategory) {
+		super(song, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.songplayer.NoteBlockSongPlayer.class);
+	}
+	
+	public NoteBlockSongPlayer(com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer songPlayer) {
+		super(songPlayer);
+	}
+
+	@Override
+	void update(String key, Object value) {
+		super.update(key, value);
+		
+		switch (key){
+			case "distance":
+				distance = (int) value;
+				break;
+			case "noteBlock":
+				noteBlock = (Block) value;
+				break;
+		}
+	}
+	
+	/**
+	 * Get the Block this SongPlayer is played at
+	 * @return Block representing a NoteBlock
+	 */
+	public Block getNoteBlock() {
+		return noteBlock;
+	}
+
+	/**
+	 * Set the Block this SongPlayer is played at
+	 */
+	public void setNoteBlock(Block noteBlock) {
+		this.noteBlock = noteBlock;
+		CallUpdate("noteBlock", noteBlock);
+	}
+
+	@Override
+	public void playTick(Player player, int tick) {
+		if (noteBlock.getType() != com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils.getNoteBlockMaterial()) {
+			return;
+		}
+		if (!player.getWorld().getName().equals(noteBlock.getWorld().getName())) {
+			// not in same world
+			return;
+		}
+		byte playerVolume = NoteBlockAPI.getPlayerVolume(player);
+
+		for (Layer layer : song.getLayerHashMap().values()) {
+			Note note = layer.getNote(tick);
+			if (note == null) {
+				continue;
+			}
+			player.playNote(noteBlock.getLocation(), InstrumentUtils.getBukkitInstrument(note.getInstrument()),
+					new org.bukkit.Note(note.getKey() - 33));
+
+			float volume = ((layer.getVolume() * (int) this.volume * (int) playerVolume) / 1000000F) 
+					* ((1F / 16F) * getDistance());
+			float pitch = NotePitch.getPitch(note.getKey() - 33);
+
+			if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+				CustomInstrument instrument = song.getCustomInstruments()
+						[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+				if (instrument.getSound() != null) {
+					CompatibilityUtils.playSound(player, noteBlock.getLocation(), 
+							instrument.getSound(), this.soundCategory, volume, pitch);
+				} else {
+					CompatibilityUtils.playSound(player, noteBlock.getLocation(), 
+							instrument.getSoundfile(), this.soundCategory, volume, pitch);
+				}
+			} else {
+				CompatibilityUtils.playSound(player, noteBlock.getLocation(),
+						InstrumentUtils.getInstrument(note.getInstrument()), this.soundCategory, volume, pitch);
+			}
+
+			if (isPlayerInRange(player)) {
+				if (!this.playerList.get(player.getName())) {
+					playerList.put(player.getName(), true);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, true));
+				}
+			} else {
+				if (this.playerList.get(player.getName())) {
+					playerList.put(player.getName(), false);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, false));
+				}
+			}
+		}
+	}
+
+	/**
+	 * Sets distance in blocks where would be player able to hear sound. 
+	 * @param distance (Default 16 blocks)
+	 */
+	public void setDistance(int distance) {
+		this.distance = distance;
+		CallUpdate("distance", distance);
+	}
+
+	public int getDistance() {
+		return distance;
+	}
+	
+	
+	/**
+	 * Returns true if the Player is able to hear the current NoteBlockSongPlayer 
+	 * @param player in range
+	 * @return ability to hear the current NoteBlockSongPlayer
+	 */	
+	@Deprecated
+	public boolean isPlayerInRange(Player player) {
+		if (player.getLocation().distance(noteBlock.getLocation()) > getDistance()) {
+			return false;
+		} else {
+			return true;
+		}
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/NotePitch.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/NotePitch.java
new file mode 100644
index 0000000000000000000000000000000000000000..513b75db92b4875b4744a2d2fe278561161996f8
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/NotePitch.java
@@ -0,0 +1,58 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.Bukkit;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.model.NotePitch}
+ */
+@Deprecated
+public enum NotePitch {
+
+	NOTE_0(0, 0.5F, 0.50000F),
+	NOTE_1(1, 0.53F, 0.52973F),
+	NOTE_2(2, 0.56F, 0.56123F),
+	NOTE_3(3, 0.6F, 0.59461F),
+	NOTE_4(4, 0.63F, 0.62995F),
+	NOTE_5(5, 0.67F, 0.66741F),
+	NOTE_6(6, 0.7F, 0.70711F),
+	NOTE_7(7, 0.76F, 0.74916F),
+	NOTE_8(8, 0.8F, 0.79370F),
+	NOTE_9(9, 0.84F, 0.84089F),
+	NOTE_10(10, 0.9F, 0.89091F),
+	NOTE_11(11, 0.94F, 0.94386F),
+	NOTE_12(12, 1.0F, 1.00000F),
+	NOTE_13(13, 1.06F, 1.05945F),
+	NOTE_14(14, 1.12F, 1.12245F),
+	NOTE_15(15, 1.18F, 1.18920F),
+	NOTE_16(16, 1.26F, 1.25993F),
+	NOTE_17(17, 1.34F, 1.33484F),
+	NOTE_18(18, 1.42F, 1.41420F),
+	NOTE_19(19, 1.5F, 1.49832F),
+	NOTE_20(20, 1.6F, 1.58741F),
+	NOTE_21(21, 1.68F, 1.68180F),
+	NOTE_22(22, 1.78F, 1.78180F),
+	NOTE_23(23, 1.88F, 1.88775F),
+	NOTE_24(24, 2.0F, 2.00000F);
+
+	public int note;
+	public float pitchPre1_9;
+	public float pitchPost1_9;
+
+	NotePitch(int note, float pitchPre1_9, float pitchPost1_9) {
+		this.note = note;
+		this.pitchPre1_9 = pitchPre1_9;
+		this.pitchPost1_9 = pitchPost1_9;
+	}
+
+	public static float getPitch(int note) {
+		boolean pre1_9 = Bukkit.getVersion().contains("1.8") || Bukkit.getVersion().contains("1.7");
+		for (NotePitch notePitch : values()) {
+			if (notePitch.note == note) {
+				return pre1_9 ? notePitch.pitchPre1_9 : notePitch.pitchPost1_9;
+			}
+		}
+
+		return 0.0F;
+	}
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/PlayerRangeStateChangeEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/PlayerRangeStateChangeEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..d550aa194d6cbf8d1f28289664475a7623316444
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/PlayerRangeStateChangeEvent.java
@@ -0,0 +1,45 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.event.PlayerRangeStateChangeEvent}
+ */
+@Deprecated
+public class PlayerRangeStateChangeEvent extends Event {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+	private Player player;
+	private boolean state;
+
+	public PlayerRangeStateChangeEvent(SongPlayer song, Player player, boolean state) {
+		this.song = song;
+		this.player = player;
+		this.state = state;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	@Override
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	public Player getPlayer() {
+		return player;
+	}
+
+	public boolean isInRange() {
+		return state;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/PositionSongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/PositionSongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..df47e467e9cf0b05a7e8a18a7f067c12f7e2add2
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/PositionSongPlayer.java
@@ -0,0 +1,124 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.songplayer.PositionSongPlayer}
+ */
+@Deprecated
+public class PositionSongPlayer extends SongPlayer {
+
+	private Location targetLocation;
+	private int distance = 16;
+
+	public PositionSongPlayer(Song song) {
+		super(song);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.songplayer.PositionSongPlayer.class);
+	}
+
+	public PositionSongPlayer(Song song, SoundCategory soundCategory) {
+		super(song, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.songplayer.PositionSongPlayer.class);
+	}
+	
+	public PositionSongPlayer(com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer songPlayer) {
+		super(songPlayer);
+	}
+
+	@Override
+	void update(String key, Object value) {
+		super.update(key, value);
+		
+		switch (key){
+			case "distance":
+				distance = (int) value;
+				break;
+			case "targetLocation":
+				targetLocation = (Location) value;
+				break;
+		}
+	}
+
+	public Location getTargetLocation() {
+		return targetLocation;
+	}
+
+	public void setTargetLocation(Location targetLocation) {
+		this.targetLocation = targetLocation;
+		CallUpdate("targetLocation", targetLocation);
+	}
+
+	@Override
+	public void playTick(Player player, int tick) {
+		if (!player.getWorld().getName().equals(targetLocation.getWorld().getName())) {
+			return; // not in same world
+		}
+
+		byte playerVolume = NoteBlockAPI.getPlayerVolume(player);
+
+		for (Layer layer : song.getLayerHashMap().values()) {
+			Note note = layer.getNote(tick);
+			if (note == null) continue;
+
+			float volume = ((layer.getVolume() * (int) this.volume * (int) playerVolume) / 1000000F) 
+					* ((1F / 16F) * getDistance());
+			float pitch = NotePitch.getPitch(note.getKey() - 33);
+
+			if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+				CustomInstrument instrument = song.getCustomInstruments()
+						[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+				if (instrument.getSound() != null) {
+					CompatibilityUtils.playSound(player, targetLocation, instrument.getSound(),
+							this.soundCategory, volume, pitch);
+				} else {
+					CompatibilityUtils.playSound(player, targetLocation, instrument.getSoundfile(),
+							this.soundCategory, volume, pitch);
+				}
+			} else {
+				CompatibilityUtils.playSound(player, targetLocation,
+						InstrumentUtils.getInstrument(note.getInstrument()), this.soundCategory, 
+						volume, pitch);
+			}
+
+			if (isPlayerInRange(player)) {
+				if (!this.playerList.get(player.getName())) {
+					playerList.put(player.getName(), true);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, true));
+				}
+			} else {
+				if (this.playerList.get(player.getName())) {
+					playerList.put(player.getName(), false);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, false));
+				}
+			}
+		}
+	}
+
+	/**
+	 * Sets distance in blocks where would be player able to hear sound. 
+	 * @param distance (Default 16 blocks)
+	 */
+	public void setDistance(int distance) {
+		this.distance = distance;
+		CallUpdate("distance", distance);
+	}
+
+	public int getDistance() {
+		return distance;
+	}
+	
+	/**
+	 * Returns true if the Player is able to hear the current PositionSongPlayer 
+	 * @param player in range
+	 * @return ability to hear the current PositionSongPlayer
+	 */
+	@Deprecated
+	public boolean isPlayerInRange(Player player) {
+		return player.getLocation().distance(targetLocation) <= getDistance();
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/RadioSongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/RadioSongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..4cfea5b4d4210d672314e86f6e84ca7fad4f0f03
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/RadioSongPlayer.java
@@ -0,0 +1,59 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+import org.bukkit.entity.Player;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.songplayer.RadioSongPlayer}
+ */
+@Deprecated
+public class RadioSongPlayer extends SongPlayer {
+
+	public RadioSongPlayer(Song song) {
+		super(song);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.songplayer.RadioSongPlayer.class);
+	}
+
+	public RadioSongPlayer(Song song, SoundCategory soundCategory) {
+		super(song, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.songplayer.RadioSongPlayer.class);
+	}
+	
+	public RadioSongPlayer(com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer songPlayer) {
+		super(songPlayer);
+	}
+
+	@Override
+	public void playTick(Player player, int tick) {
+		byte playerVolume = NoteBlockAPI.getPlayerVolume(player);
+
+		for (Layer layer : song.getLayerHashMap().values()) {
+			Note note = layer.getNote(tick);
+			if (note == null) {
+				continue;
+			}
+
+			float volume = (layer.getVolume() * (int) this.volume * (int) playerVolume) / 1000000F;
+			float pitch = NotePitch.getPitch(note.getKey() - 33);
+
+			if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+				CustomInstrument instrument = song.getCustomInstruments()
+						[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+				if (instrument.getSound() != null) {
+					CompatibilityUtils.playSound(player, player.getEyeLocation(),
+							instrument.getSound(),
+							this.soundCategory, volume, pitch);
+				} else {
+					CompatibilityUtils.playSound(player, player.getEyeLocation(),
+							instrument.getSoundfile(),
+							this.soundCategory, volume, pitch);
+				}
+			} else {
+				CompatibilityUtils.playSound(player, player.getEyeLocation(),
+						InstrumentUtils.getInstrument(note.getInstrument()), this.soundCategory, volume, pitch);
+			}
+		}
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/Song.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/Song.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4ea9480cd677c4752d9a0fc978b4788545023d5
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/Song.java
@@ -0,0 +1,183 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+
+import java.io.File;
+import java.util.HashMap;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.model.Song}
+ */
+@Deprecated
+public class Song implements Cloneable {
+
+	private HashMap<Integer, Layer> layerHashMap = new HashMap<Integer, Layer>();
+	private short songHeight;
+	private short length;
+	private String title;
+	private File path;
+	private String author;
+	private String description;
+	private float speed;
+	private float delay;
+	private CustomInstrument[] customInstruments;
+	private int firstCustomInstrumentIndex;
+
+	/**
+	 * Create Song instance by copying other Song parameters
+	 * @param other song
+	 */
+	public Song(Song other) {
+		this(other.getSpeed(), other.getLayerHashMap(), other.getSongHeight(),
+				other.getLength(), other.getTitle(), other.getAuthor(),
+				other.getDescription(), other.getPath(), other.getFirstCustomInstrumentIndex(), other.getCustomInstruments());
+	}
+
+	/**
+	 * @deprecated Use {@link #Song(float, HashMap, short, short, String, String, String, File, int)}
+	 * @param speed
+	 * @param layerHashMap
+	 * @param songHeight
+	 * @param length
+	 * @param title
+	 * @param author
+	 * @param description
+	 * @param path
+	 */
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path) {
+		this(speed, layerHashMap, songHeight, length, title, author, description, path, InstrumentUtils.getCustomInstrumentFirstIndex(), new CustomInstrument[0]);
+	}
+
+	/**
+	 * @deprecated Use {@link #Song(float, HashMap, short, short, String, String, String, File, int, CustomInstrument[])}
+	 * @param speed
+	 * @param layerHashMap
+	 * @param songHeight
+	 * @param length
+	 * @param title
+	 * @param author
+	 * @param description
+	 * @param path
+	 * @param customInstruments
+	 */
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path, CustomInstrument[] customInstruments) {
+		this(speed, layerHashMap, songHeight, length, title, author, description, path, InstrumentUtils.getCustomInstrumentFirstIndex(), customInstruments);
+	}
+
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path, int firstCustomInstrumentIndex) {
+		this(speed, layerHashMap, songHeight, length, title, author, description, path, firstCustomInstrumentIndex, new CustomInstrument[0]);
+	}
+
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path, int firstCustomInstrumentIndex, CustomInstrument[] customInstruments) {
+		this.speed = speed;
+		delay = 20 / speed;
+		this.layerHashMap = layerHashMap;
+		this.songHeight = songHeight;
+		this.length = length;
+		this.title = title;
+		this.author = author;
+		this.description = description;
+		this.path = path;
+		this.firstCustomInstrumentIndex = firstCustomInstrumentIndex;
+		this.customInstruments = customInstruments;
+	}
+
+	/**
+	 * Gets all Layers in this Song and their index
+	 * @return HashMap of Layers and their index
+	 */
+	public HashMap<Integer, Layer> getLayerHashMap() {
+		return layerHashMap;
+	}
+
+	/**
+	 * Gets the Song's height
+	 * @return Song height
+	 */
+	public short getSongHeight() {
+		return songHeight;
+	}
+
+	/**
+	 * Gets the length in ticks of this Song
+	 * @return length of this Song
+	 */
+	public short getLength() {
+		return length;
+	}
+
+	/**
+	 * Gets the title / name of this Song
+	 * @return title of the Song
+	 */
+	public String getTitle() {
+		return title;
+	}
+
+	/**
+	 * Gets the author of the Song
+	 * @return author
+	 */
+	public String getAuthor() {
+		return author;
+	}
+
+	/**
+	 * Returns the File from which this Song is sourced
+	 * @return file of this Song
+	 */
+	public File getPath() {
+		return path;
+	}
+
+	/**
+	 * Gets the description of this Song
+	 * @return description
+	 */
+	public String getDescription() {
+		return description;
+	}
+
+	/**
+	 * Gets the speed (ticks per second) of this Song
+	 * @return
+	 */
+	public float getSpeed() {
+		return speed;
+	}
+
+	/**
+	 * Gets the delay of this Song
+	 * @return delay
+	 */
+	public float getDelay() {
+		return delay;
+	}
+
+	/**
+	 * Gets the CustomInstruments made for this Song
+	 * @see CustomInstrument
+	 * @return array of CustomInstruments
+	 */
+	public CustomInstrument[] getCustomInstruments() {
+		return customInstruments;
+	}
+
+	@Override
+	public Song clone() {
+		return new Song(this);
+	}
+
+	public int getFirstCustomInstrumentIndex() {
+		return firstCustomInstrumentIndex;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/SongDestroyingEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongDestroyingEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..51201d31f6ce0f7fe2a76f2151ef93f054759ced
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongDestroyingEvent.java
@@ -0,0 +1,43 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.event.SongDestroyingEvent}
+ */
+@Deprecated
+public class SongDestroyingEvent extends Event implements Cancellable {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+	private boolean cancelled = false;
+
+	public SongDestroyingEvent(SongPlayer song) {
+		this.song = song;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+
+	@Override
+	public boolean isCancelled() {
+		return cancelled;
+	}
+
+	@Override
+	public void setCancelled(boolean arg0) {
+		cancelled = arg0;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/SongEndEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongEndEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b67ccad6168562aac6846e919a7e9c8993e7189d
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongEndEvent.java
@@ -0,0 +1,30 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.event.SongEndEvent}
+ */
+@Deprecated
+public class SongEndEvent extends Event {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+
+	public SongEndEvent(SongPlayer song) {
+		this.song = song;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/SongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..9cfd5c58fee970bcb2b9e9c1c058a45c8c833614
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongPlayer.java
@@ -0,0 +1,525 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.*;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer}
+ */
+@Deprecated
+public abstract class SongPlayer {
+
+	protected Song song;
+
+	protected boolean playing = false;
+	protected short tick = -1;
+	protected Map<String, Boolean> playerList = Collections.synchronizedMap(new HashMap<String, Boolean>());
+
+	protected boolean autoDestroy = false;
+	protected boolean destroyed = false;
+
+	protected Thread playerThread;
+
+	protected byte volume = 100;
+	protected byte fadeStart = volume;
+	protected byte fadeTarget = 100;
+	protected int fadeDuration = 60;
+	protected int fadeDone = 0;
+	protected FadeType fadeType = FadeType.FADE_LINEAR;
+
+	private final Lock lock = new ReentrantLock();
+
+	protected NoteBlockPlayerMain plugin;
+
+	protected SoundCategory soundCategory;
+	
+	private com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer newSongPlayer;
+
+	public SongPlayer(Song song) {
+		this(song, SoundCategory.MASTER);
+	}
+
+	public SongPlayer(Song song, SoundCategory soundCategory) {
+		NoteBlockAPI.getAPI().handleDeprecated(Thread.currentThread().getStackTrace());
+		
+		this.song = song;
+		this.soundCategory = soundCategory;
+		plugin = NoteBlockPlayerMain.plugin;
+		start();
+	}
+	
+	SongPlayer(com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer songPlayer){
+		newSongPlayer = songPlayer;
+		song = createSongFromNew(songPlayer.getSong());
+		plugin = NoteBlockPlayerMain.plugin;
+	}
+	
+	private Song createSongFromNew(com.xxmicloxx.NoteBlockAPI.model.Song s){
+		HashMap<Integer, Layer> layerHashMap = new HashMap<Integer, Layer>();
+		for (Integer i : s.getLayerHashMap().keySet()){
+			com.xxmicloxx.NoteBlockAPI.model.Layer l = s.getLayerHashMap().get(i);
+			HashMap<Integer, Note> noteHashMap = new HashMap<Integer, Note>();
+			for (Integer iL : l.getNotesAtTicks().keySet()){
+				com.xxmicloxx.NoteBlockAPI.model.Note note = l.getNotesAtTicks().get(iL);
+				noteHashMap.put(iL, new Note(note.getInstrument(), note.getKey()));
+			}
+			Layer layer = new Layer();
+			layer.setHashMap(noteHashMap);
+			layer.setVolume(l.getVolume());
+			layerHashMap.put(i, layer);
+		}
+		CustomInstrument[] instruments = new CustomInstrument[s.getCustomInstruments().length];
+		for (int i = 0; i < s.getCustomInstruments().length; i++){
+			com.xxmicloxx.NoteBlockAPI.model.CustomInstrument ci = s.getCustomInstruments()[i];
+			instruments[i] = new CustomInstrument(ci.getIndex(), ci.getName(), ci.getSoundFileName());
+		}
+		
+		return new Song(s.getSpeed(), layerHashMap, s.getSongHeight(), s.getLength(), s.getTitle(), s.getAuthor(), s.getDescription(), s.getPath(), instruments);
+	}
+
+	void update(String key, Object value){
+		switch (key){
+			case "playing":
+				playing = (boolean) value;
+				break;
+			case "fadeType":
+				fadeType = FadeType.valueOf((String) value);
+				break;
+			case "fadeTarget":
+				fadeTarget = (byte) value;
+				break;
+			case "fadeStart":
+				fadeStart = (byte) value;
+				break;
+			case "fadeDuration":
+				fadeDuration = (int) value;
+				break;
+			case "fadeDone":
+				fadeDone = (int) value;
+				break;
+			case "tick":
+				tick = (short) value;
+				break;
+			case "addplayer":
+				addPlayer((Player) value, false);
+				break;
+			case "removeplayer":
+				removePlayer((Player) value, false);
+				break;
+			case "autoDestroy":
+				autoDestroy = (boolean) value;
+				break;
+			case "volume":
+				volume = (byte) value;
+				break;
+			case "soundCategory":
+				soundCategory = SoundCategory.valueOf((String) value);
+				break;
+			case "song":
+				song = createSongFromNew((com.xxmicloxx.NoteBlockAPI.model.Song) value);
+				break;
+				
+		}
+	}
+
+	/**
+	 * Gets the FadeType for this SongPlayer (unused)
+	 * @return FadeType
+	 */
+	public FadeType getFadeType() {
+		return fadeType;
+	}
+
+	/**
+	 * Sets the FadeType for this SongPlayer
+	 * @param fadeType
+	 */
+	public void setFadeType(FadeType fadeType) {
+		this.fadeType = fadeType;
+		CallUpdate("fadetype", fadeType.name());
+	}
+
+	/**
+	 * Target volume for fade
+	 * @return byte representing fade target
+	 */
+	public byte getFadeTarget() {
+		return fadeTarget;
+	}
+
+	/**
+	 * Set target volume for fade
+	 * @param fadeTarget
+	 */
+	public void setFadeTarget(byte fadeTarget) {
+		this.fadeTarget = fadeTarget;
+		CallUpdate("fadeTarget", fadeTarget);
+	}
+
+	/**
+	 * Gets the starting time for the fade
+	 * @return
+	 */
+	public byte getFadeStart() {
+		return fadeStart;
+	}
+
+	/**
+	 * Sets the starting time for the fade
+	 * @param fadeStart
+	 */
+	public void setFadeStart(byte fadeStart) {
+		this.fadeStart = fadeStart;
+		CallUpdate("fadeStart", fadeStart);
+	}
+
+	/**
+	 * Gets the duration of the fade
+	 * @return duration of the fade
+	 */
+	public int getFadeDuration() {
+		return fadeDuration;
+	}
+
+	/**
+	 * Sets the duration of the fade
+	 * @param fadeDuration
+	 */
+	public void setFadeDuration(int fadeDuration) {
+		this.fadeDuration = fadeDuration;
+		CallUpdate("fadeDuration", fadeDuration);
+	}
+
+	/**
+	 * Gets the tick when fade will be finished
+	 * @return tick
+	 */
+	public int getFadeDone() {
+		return fadeDone;
+	}
+
+	/**
+	 * Sets the tick when fade will be finished
+	 * @param fadeDone
+	 */
+	public void setFadeDone(int fadeDone) {
+		this.fadeDone = fadeDone;
+		CallUpdate("fadeDone", fadeDone);
+	}
+
+	/**
+	 * Calculates the fade at the given time and sets the current volume
+	 */
+	protected void calculateFade() {
+		if (fadeDone == fadeDuration) {
+			return; // no fade today
+		}
+		double targetVolume = Interpolator.interpLinear(
+				new double[]{0, fadeStart, fadeDuration, fadeTarget}, fadeDone);
+		setVolume((byte) targetVolume);
+		fadeDone++;
+		CallUpdate("fadeDone", fadeDone);
+	}
+
+	/**
+	 * Starts this SongPlayer
+	 */
+	private void start() {
+		plugin.doAsync(() -> {
+			while (!destroyed) {
+				long startTime = System.currentTimeMillis();
+				lock.lock();
+				try {
+					if (destroyed || NoteBlockAPI.getAPI().isDisabling()){
+						break;
+					}
+
+					if (playing) {
+						calculateFade();
+						tick++;
+						if (tick > song.getLength()) {
+							playing = false;
+							tick = -1;
+							SongEndEvent event = new SongEndEvent(SongPlayer.this);
+							plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+							if (autoDestroy) {
+								destroy();
+							}
+							continue;
+						}
+						CallUpdate("tick", tick);
+
+						plugin.doSync(() -> {
+							for (String s : playerList.keySet()) {
+	                            Player p = Bukkit.getPlayerExact(s);
+	                            if (p == null) {
+	                                // offline...
+	                                continue;
+	                            }
+	                            playTick(p, tick);
+							}
+						});
+					}
+				} catch (Exception e) {
+					e.printStackTrace();
+				} finally {
+					lock.unlock();
+				}
+
+				if (destroyed) {
+					break;
+				}
+
+				long duration = System.currentTimeMillis() - startTime;
+				float delayMillis = song.getDelay() * 50;
+				if (duration < delayMillis) {
+					try {
+						Thread.sleep((long) (delayMillis - duration));
+					} catch (InterruptedException e) {
+						// do nothing
+					}
+				}
+			}
+		});
+	}
+
+	/**
+	 * Gets list of current Player usernames listening to this SongPlayer
+	 * @return list of Player usernames
+	 * @deprecated use getPlayerUUIDs
+	 */
+	@Deprecated
+	public List<String> getPlayerList() {
+		List<String> list = new ArrayList<>();
+		for (String s : playerList.keySet()) {
+			list.add(Bukkit.getPlayer(s).getName());
+		}
+		return Collections.unmodifiableList(list);
+	}
+
+	/**
+	 * Adds a Player to the list of Players listening to this SongPlayer
+	 * @param player
+	 */
+	public void addPlayer(Player player) {
+		addPlayer(player, true);
+	}
+	
+	private void addPlayer(Player player, boolean notify){
+		lock.lock();
+		try {
+			if (!playerList.containsKey(player.getName())) {
+				playerList.put(player.getName(), false);
+				ArrayList<SongPlayer> songs = NoteBlockPlayerMain.plugin.playingSongs
+						.get(player.getName());
+				if (songs == null) {
+					songs = new ArrayList<SongPlayer>();
+				}
+				songs.add(this);
+				NoteBlockPlayerMain.plugin.playingSongs.put(player.getName(), songs);
+				if (notify){
+					CallUpdate("addplayer", player);
+				}
+			}
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Returns whether the SongPlayer is set to destroy itself when no one is listening 
+	 * or when the Song ends
+	 * @return if autoDestroy is enabled
+	 */
+	public boolean getAutoDestroy() {
+		lock.lock();
+		try {
+			return autoDestroy;
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Sets autoDestroy
+	 * @param autoDestroy if autoDestroy is enabled
+	 */
+	public void setAutoDestroy(boolean autoDestroy) {
+		lock.lock();
+		try {
+			this.autoDestroy = autoDestroy;
+			CallUpdate("autoDestroy", autoDestroy);
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Plays the Song for the specific player
+	 * @param player to play this SongPlayer for
+	 * @param tick to play at
+	 */
+	public abstract void playTick(Player player, int tick);
+
+	public void destroy() {
+		lock.lock();
+		try {
+			SongDestroyingEvent event = new SongDestroyingEvent(this);
+			plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+			//Bukkit.getScheduler().cancelTask(threadId);
+			if (event.isCancelled()) {
+				return;
+			}
+			destroyed = true;
+			playing = false;
+			setTick((short) -1);
+			CallUpdate("destroyed", destroyed);
+			CallUpdate("playing", playing);
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Returns whether the SongPlayer is actively playing
+	 * @return is playing
+	 */
+	public boolean isPlaying() {
+		return playing;
+	}
+
+	/**
+	 * Sets whether the SongPlayer is playing
+	 * @param playing
+	 */
+	public void setPlaying(boolean playing) {
+		this.playing = playing;
+		if (!playing) {
+			SongStoppedEvent event = new SongStoppedEvent(this);
+			plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+		}
+		CallUpdate("playing", playing);
+	}
+
+	/**
+	 * Gets the current tick of this SongPlayer
+	 * @return
+	 */
+	public short getTick() {
+		return tick;
+	}
+
+	/**
+	 * Sets the current tick of this SongPlayer
+	 * @param tick
+	 */
+	public void setTick(short tick) {
+		this.tick = tick;
+		CallUpdate("tick", tick);
+	}
+
+	/**
+	 * Removes a player from this SongPlayer
+	 * @param player to remove
+	 */
+	public void removePlayer(Player player) {
+		removePlayer(player, true);
+	}
+	
+	private void removePlayer(Player player, boolean notify) {
+		lock.lock();
+		try {
+			if (notify){
+				CallUpdate("removeplayer", player);
+			}
+			playerList.remove(player.getName());
+			if (NoteBlockPlayerMain.plugin.playingSongs.get(player.getName()) == null) {
+				return;
+			}
+			ArrayList<SongPlayer> songs = new ArrayList<>(
+					NoteBlockPlayerMain.plugin.playingSongs.get(player.getName()));
+			songs.remove(this);
+			NoteBlockPlayerMain.plugin.playingSongs.put(player.getName(), songs);
+			if (playerList.isEmpty() && autoDestroy) {
+				SongEndEvent event = new SongEndEvent(this);
+				plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+				destroy();
+			}
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Gets the current volume of this SongPlayer
+	 * @return volume (0-100)
+	 */
+	public byte getVolume() {
+		return volume;
+	}
+
+	/**
+	 * Sets the current volume of this SongPlayer
+	 * @param volume (0-100)
+	 */
+	public void setVolume(byte volume) {
+		this.volume = volume;
+		CallUpdate("volume", volume);
+	}
+
+	/**
+	 * Gets the Song being played by this SongPlayer
+	 * @return
+	 */
+	public Song getSong() {
+		return song;
+	}
+
+	/**
+	 * Gets the SoundCategory of this SongPlayer
+	 * @see SoundCategory
+	 * @return SoundCategory of this SongPlayer
+	 */
+	public SoundCategory getCategory() {
+		return soundCategory;
+	}
+
+	/**
+	 * Sets the SoundCategory for this SongPlayer
+	 * @param soundCategory
+	 */
+	public void setCategory(SoundCategory soundCategory) {
+		this.soundCategory = soundCategory;
+		CallUpdate("soundCategory", soundCategory.name());
+	}
+	
+	void CallUpdate(String key, Object value){
+		try {
+			Method m = com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer.class.getDeclaredMethod("update", String.class, Object.class);
+			m.setAccessible(true);
+			m.invoke(newSongPlayer, key, value);
+		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException
+				| SecurityException e) {
+			e.printStackTrace();
+		}
+	}
+	
+	void makeNewClone(Class newClass){
+		try {
+			Constructor c = newClass.getDeclaredConstructor(new Class[] { SongPlayer.class });
+			c.setAccessible(true);
+			newSongPlayer = (com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer) c.newInstance(new Object[]{this});
+		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+				| NoSuchMethodException | SecurityException e) {
+			e.printStackTrace();
+		}
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/SongStoppedEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongStoppedEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..fbf711acaaddd4129ebf9441b49622c10ae66ee9
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/SongStoppedEvent.java
@@ -0,0 +1,31 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.event.SongStoppedEvent}
+ */
+@Deprecated
+public class SongStoppedEvent extends Event {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer songPlayer;
+
+	public SongStoppedEvent(SongPlayer songPlayer) {
+		this.songPlayer = songPlayer;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	public SongPlayer getSongPlayer() {
+		return songPlayer;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/SoundCategory.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/SoundCategory.java
new file mode 100644
index 0000000000000000000000000000000000000000..25e143ef518d1936137ded05098c1cc20fc022f0
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/SoundCategory.java
@@ -0,0 +1,20 @@
+package com.xxmicloxx.NoteBlockAPI;
+
+/**
+ * @deprecated {@link com.xxmicloxx.NoteBlockAPI.model.SoundCategory}
+ */
+@Deprecated
+public enum SoundCategory {
+
+	MASTER,
+	MUSIC,
+	RECORDS,
+	WEATHER,
+	BLOCKS,
+	HOSTILE,
+	NEUTRAL,
+	PLAYERS,
+	AMBIENT,
+	VOICE;
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/event/PlayerRangeStateChangeEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/PlayerRangeStateChangeEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..753345ed5770b29deaeeff191d24686f86ab852e
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/PlayerRangeStateChangeEvent.java
@@ -0,0 +1,58 @@
+package com.xxmicloxx.NoteBlockAPI.event;
+
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called whenever a Player enters or leave the range of a stationary SongPlayer
+ *
+ */
+public class PlayerRangeStateChangeEvent extends Event {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+	private Player player;
+	private boolean state;
+
+	public PlayerRangeStateChangeEvent(SongPlayer song, Player player, boolean state) {
+		this.song = song;
+		this.player = player;
+		this.state = state;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	@Override
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+
+	/**
+	 * Returns SongPlayer which range Player enters or leaves
+	 * @return SongPlayer
+	 */
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	/**
+	 * Returns Player which enter/leave SongPlayer range
+	 * @return Player
+	 */
+	public Player getPlayer() {
+		return player;
+	}
+
+	/**
+	 * Returns true if Player is actually in SongPlayer range
+	 * @return boolean determining if is Player in SongPlayer range
+	 */
+	public boolean isInRange() {
+		return state;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongDestroyingEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongDestroyingEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..6d465eae0c1c6d863136e72328cfa1df105f2428
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongDestroyingEvent.java
@@ -0,0 +1,51 @@
+package com.xxmicloxx.NoteBlockAPI.event;
+
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called whenever a SongPlayer is destroyed
+ * @see SongPlayer
+ *
+ */
+public class SongDestroyingEvent extends Event implements Cancellable {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+	private boolean cancelled = false;
+
+	public SongDestroyingEvent(SongPlayer song) {
+		this.song = song;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	/**
+	 * Returns SongPlayer which is being destroyed
+	 * @return SongPlayer
+	 */
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+
+	@Override
+	public boolean isCancelled() {
+		return cancelled;
+	}
+
+	@Override
+	public void setCancelled(boolean arg0) {
+		cancelled = arg0;
+	}
+
+	
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongEndEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongEndEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..186453a24d73269628ebbdbf7cae710fccebb23c
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongEndEvent.java
@@ -0,0 +1,38 @@
+package com.xxmicloxx.NoteBlockAPI.event;
+
+import com.xxmicloxx.NoteBlockAPI.model.Song;
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a Song ends
+ * or when no players are listening and auto destroy is enabled
+ * @see SongPlayer
+ *
+ */
+public class SongEndEvent extends Event {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+
+	public SongEndEvent(SongPlayer song) {
+		this.song = song;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	/**
+	 * Returns SongPlayer which {@link Song} ends
+	 * @return SongPlayer
+	 */
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongLoopEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongLoopEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..a2c352e9d86a8271c1883ffee70ab779c6d4f6c0
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongLoopEvent.java
@@ -0,0 +1,45 @@
+package com.xxmicloxx.NoteBlockAPI.event;
+
+import com.xxmicloxx.NoteBlockAPI.model.Song;
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+public class SongLoopEvent extends Event implements Cancellable {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+	private boolean cancelled = false;
+
+	public SongLoopEvent(SongPlayer song) {
+		this.song = song;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	/**
+	 * Returns SongPlayer which {@link Song} ends and is going to start again
+	 * @return SongPlayer
+	 */
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+
+	@Override
+	public boolean isCancelled() {
+		return cancelled;
+	}
+
+	@Override
+	public void setCancelled(boolean cancel) {
+		this.cancelled = cancel;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongNextEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongNextEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3113e43ad40ffb5e377d2326dcb29f755997413
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongNextEvent.java
@@ -0,0 +1,32 @@
+package com.xxmicloxx.NoteBlockAPI.event;
+
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+public class SongNextEvent extends Event {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer song;
+
+	public SongNextEvent(SongPlayer song) {
+		this.song = song;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	/**
+	 * Returns SongPlayer which is going to play next song in playlist
+	 * @return SongPlayer
+	 */
+	public SongPlayer getSongPlayer() {
+		return song;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongStoppedEvent.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongStoppedEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..66041db4dc2e16bbd28a47b70365c6c895f496ab
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/event/SongStoppedEvent.java
@@ -0,0 +1,38 @@
+package com.xxmicloxx.NoteBlockAPI.event;
+
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+
+/**
+ * Called whenever a SongPlayer is stopped
+ * @see SongPlayer
+ */
+public class SongStoppedEvent extends Event {
+
+	private static final HandlerList handlers = new HandlerList();
+	private SongPlayer songPlayer;
+
+	public SongStoppedEvent(SongPlayer songPlayer) {
+		this.songPlayer = songPlayer;
+	}
+
+	public static HandlerList getHandlerList() {
+		return handlers;
+	}
+
+	/**
+	 * Returns SongPlayer which is now stopped
+	 * @return SongPlayer
+	 */	
+	public SongPlayer getSongPlayer() {
+		return songPlayer;
+	}
+
+	public HandlerList getHandlers() {
+		return handlers;
+	}
+
+}
+
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/CustomInstrument.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/CustomInstrument.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b431731196f126a74f148cf39ac63e7ac051901
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/CustomInstrument.java
@@ -0,0 +1,60 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+/**
+ * Create custom instruments from a sound file
+ * 
+ */
+public class CustomInstrument {
+	
+	private byte index;
+	private String name;
+	private String soundFileName;
+	private org.bukkit.Sound sound;
+
+	/**
+	 * Creates a CustomInstrument
+	 * @param index
+	 * @param name
+	 * @param soundFileName
+	 */
+	public CustomInstrument(byte index, String name, String soundFileName) {
+		this.index = index;
+		this.name = name;
+		this.soundFileName = soundFileName.replaceAll(".ogg", "");
+		if (this.soundFileName.equalsIgnoreCase("pling") || this.soundFileName.equalsIgnoreCase("block.note_block.pling")) {
+			this.sound = Sound.NOTE_PLING.bukkitSound();
+		}
+	}
+
+	/**
+	 * Gets index of CustomInstrument
+	 * @return index
+	 */
+	public byte getIndex() {
+		return index;
+	}
+
+	/**
+	 * Gets name of CustomInstrument
+	 * @return name
+	 */
+	public String getName() {
+		return name;
+	}
+
+	/**
+	 * Gets file name of the sound
+	 * @return file name
+	 */
+	public String getSoundFileName() {
+		return soundFileName;
+	}
+
+	/**
+	 * Gets the org.bukkit.Sound enum for this CustomInstrument
+	 * @return org.bukkit.Sound enum
+	 */
+	public org.bukkit.Sound getSound() {
+		return sound;
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/FadeType.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/FadeType.java
new file mode 100644
index 0000000000000000000000000000000000000000..a80966b7610e21ed53225ad6cd93412ab031f3d7
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/FadeType.java
@@ -0,0 +1,8 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+public enum FadeType {
+
+	NONE,
+	LINEAR
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Layer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Layer.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab0b1631515f316edd2b6d1c5de2839537b71d6f
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Layer.java
@@ -0,0 +1,91 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+import java.util.HashMap;
+
+/**
+ * Represents a series of notes in Note Block Studio. 
+ * A Layer can have a maximum of one note per tick (20 ticks a second)
+ *
+ */
+public class Layer {
+
+	private HashMap<Integer, Note> notesAtTicks = new HashMap<Integer, Note>();
+	private byte volume = 100;
+	private int panning = 100;
+	private String name = "";
+
+	/**
+	 * Gets the notes in the Layer with the tick they are created as a hash map
+	 * @return HashMap of notes with the tick they are played at
+	 */
+	public HashMap<Integer, Note> getNotesAtTicks() {
+		return notesAtTicks;
+	}
+
+	/**
+	 * Sets the notes in the Layer with the tick they are created as a hash map
+	 */
+	public void setNotesAtTicks(HashMap<Integer, Note> notesAtTicks) {
+		this.notesAtTicks = notesAtTicks;
+	}
+
+	/**
+	 * Gets the name of the Layer
+	 */
+	public String getName() {
+		return name;
+	}
+
+	/**
+	 * Sets the name of the Layer
+	 */
+	public void setName(String name) {
+		this.name = name;
+	}
+
+	/**
+	 * Gets the note played at a given tick
+	 */
+	public Note getNote(int tick) {
+		return notesAtTicks.get(tick);
+	}
+
+	/**
+	 * Sets the given note at the given tick in the Layer
+	 */
+	public void setNote(int tick, Note note) {
+		notesAtTicks.put(tick, note);
+	}
+
+	/**
+	 * Gets the volume of all notes in the Layer
+	 * @return byte representing the volume
+	 */
+	public byte getVolume() {
+		return volume;
+	}
+
+	/**
+	 * Sets the volume for all notes in the Layer
+	 * @param volume
+	 */
+	public void setVolume(byte volume) {
+		this.volume = volume;
+	}
+
+	/**
+	 * Gets the panning of all notes in the Layer
+	 * @return byte representing the panning
+	 */
+	public int getPanning() {
+		return panning;
+	}
+
+	/**
+	 * Sets the panning for all notes in the Layer
+	 * @param panning
+	 */
+	public void setPanning(int panning) {
+		this.panning = panning;
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Note.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Note.java
new file mode 100644
index 0000000000000000000000000000000000000000..a704070bdf02829d8213af9f4e1b56151d5bbaba
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Note.java
@@ -0,0 +1,112 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+/**
+ * Represents a note played; contains the instrument and the key
+ * @see NotePitch
+ *
+ */
+public class Note {
+
+	private byte instrument;
+	private byte key;
+	private byte velocity;
+	private int panning;
+	private short pitch;
+
+	public Note(byte instrument, byte key) {
+		this(instrument, key, (byte) 100, (byte) 100, (short) 0);
+	}
+
+	public Note(byte instrument, byte key, byte velocity, int panning, short pitch) {
+		this.instrument = instrument;
+		this.key = key;
+		this.velocity = velocity;
+		this.panning = panning;
+		this.pitch = pitch;
+	}
+
+	/**
+	 * Gets instrument number
+	 */
+	public byte getInstrument() {
+		return instrument;
+	}
+
+	/**
+	 * Sets instrument number
+	 */
+	public void setInstrument(byte instrument) {
+		this.instrument = instrument;
+	}
+
+	/**
+	 * Returns note key number (Minecraft key 0 corresponds to key 33)
+	 * @return
+	 */
+	public byte getKey() {
+		return key;
+	}
+
+	/**
+	 * Sets note key number (Minecraft key 0 corresponds to key 33)
+	 * @param key
+	 */
+	public void setKey(byte key) {
+		this.key = key;
+	}
+
+	/**
+	 * Returns note pitch.
+	 * 100 = 1 key
+	 * 1200 = 1 octave
+ 	 * @return
+	 */
+	public short getPitch() {
+		return pitch;
+	}
+
+	/**
+	 * Sets note pitch.
+	 * 100 = 1 key
+	 * 1200 = 1 octave
+	 * @param pitch note pitch
+	 */
+	public void setPitch(short pitch) {
+		this.pitch = pitch;
+	}
+
+	/**
+	 * Returns note velocity (volume)
+	 * @return
+	 */
+	public byte getVelocity() {
+		return velocity;
+	}
+
+	/**
+	 * Sets note velocity (volume)
+	 * @param velocity number from 0 - 100
+	 */
+	public void setVelocity(byte velocity) {
+		if (velocity < 0) velocity = 0;
+		if (velocity > 100) velocity = 100;
+
+		this.velocity = velocity;
+	}
+
+	/**
+	 * Returns stereo panning of this note
+	 * @return
+	 */
+	public int getPanning() {
+		return panning;
+	}
+
+	/**
+	 * Sets stereo panning of this note
+	 * @param panning
+	 */
+	public void setPanning(int panning) {
+		this.panning = panning;
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/NotePitch.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/NotePitch.java
new file mode 100644
index 0000000000000000000000000000000000000000..fec1207cef7ab9d077ff801b3030f205c743094d
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/NotePitch.java
@@ -0,0 +1,59 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+import com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils;
+
+/**
+ * Represents pitches of every noteblock note pre- &amp; post-1.9
+ * @deprecated Use NoteUtils
+ */
+@Deprecated()
+public enum NotePitch {
+
+	NOTE_0(0, 0.5F, 0.50000F),
+	NOTE_1(1, 0.53F, 0.52973F),
+	NOTE_2(2, 0.56F, 0.56123F),
+	NOTE_3(3, 0.6F, 0.59461F),
+	NOTE_4(4, 0.63F, 0.62995F),
+	NOTE_5(5, 0.67F, 0.66741F),
+	NOTE_6(6, 0.7F, 0.70711F),
+	NOTE_7(7, 0.76F, 0.74916F),
+	NOTE_8(8, 0.8F, 0.79370F),
+	NOTE_9(9, 0.84F, 0.84089F),
+	NOTE_10(10, 0.9F, 0.89091F),
+	NOTE_11(11, 0.94F, 0.94386F),
+	NOTE_12(12, 1.0F, 1.00000F),
+	NOTE_13(13, 1.06F, 1.05945F),
+	NOTE_14(14, 1.12F, 1.12245F),
+	NOTE_15(15, 1.18F, 1.18920F),
+	NOTE_16(16, 1.26F, 1.25993F),
+	NOTE_17(17, 1.34F, 1.33484F),
+	NOTE_18(18, 1.42F, 1.41420F),
+	NOTE_19(19, 1.5F, 1.49832F),
+	NOTE_20(20, 1.6F, 1.58741F),
+	NOTE_21(21, 1.68F, 1.68180F),
+	NOTE_22(22, 1.78F, 1.78180F),
+	NOTE_23(23, 1.88F, 1.88775F),
+	NOTE_24(24, 2.0F, 2.00000F);
+
+	public int note;
+	public float pitchPre1_9;
+	public float pitchPost1_9;
+
+	NotePitch(int note, float pitchPre1_9, float pitchPost1_9) {
+		this.note = note;
+		this.pitchPre1_9 = pitchPre1_9;
+		this.pitchPost1_9 = pitchPost1_9;
+	}
+
+	public static float getPitch(int note) {
+		boolean pre1_9 = CompatibilityUtils.getServerVersion() < 0.0109f;
+		for (NotePitch notePitch : values()) {
+			if (notePitch.note == note) {
+				return pre1_9 ? notePitch.pitchPre1_9 : notePitch.pitchPost1_9;
+			}
+		}
+
+		return 0.0F;
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Playlist.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Playlist.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd2efacc68de14b87fa2cdaa9b451c424918acfd
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Playlist.java
@@ -0,0 +1,126 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class Playlist {
+
+	ArrayList<Song> songs = new ArrayList<>();
+	
+	public Playlist(Song ...songs){
+		if (songs.length == 0){
+			throw new IllegalArgumentException("Cannot create empty playlist");
+		}
+		checkNull(songs);
+		this.songs.addAll(Arrays.asList(songs));
+	}
+	
+	/**
+	 * Add array of {@link Song} to playlist
+	 * @param songs
+	 */
+	public void add(Song ...songs){
+		if (songs.length == 0){
+			return;
+		}
+		checkNull(songs);
+		this.songs.addAll(Arrays.asList(songs));
+	}
+
+	/**
+	 * Insert array of {@link Song} at a specified index
+	 * @param index
+	 * @param songs
+	 */
+	public void insert(int index, Song ...songs){
+		if (songs.length == 0){
+			return;
+		}
+		if (index > this.songs.size()){
+			throw new IllegalArgumentException("Index is higher than playlist size");
+		}
+		checkNull(songs);
+		this.songs.addAll(index, Arrays.asList(songs));
+	}
+	
+	private void checkNull(Song ...songs){
+		List<Song> songList = Arrays.asList(songs);
+		if (songList.contains(null)){
+			throw new IllegalArgumentException("Cannot add null to playlist");
+		}
+	}
+	
+	/**
+	 * Removes songs from playlist
+	 * @param songs
+	 * @throws IllegalArgumentException when you try to remove all {@link Song} from {@link Playlist}
+	 */
+	public void remove(Song ...songs){
+		ArrayList<Song> songsTemp = new ArrayList<>();
+		songsTemp.addAll(this.songs);
+		songsTemp.removeAll(Arrays.asList(songs));
+		if (songsTemp.size() > 0){
+			this.songs = songsTemp;
+		} else {
+			throw new IllegalArgumentException("Cannot remove all songs from playlist");
+		}
+	}
+	
+	/**
+	 * Get {@link Song} in playlist at specified index
+	 * @param songNumber - song index
+	 * @return
+	 */
+	public Song get(int songNumber){
+		return songs.get(songNumber);
+	}
+	
+	/**
+	 * Get number of {@link Song} in playlist
+	 * @return
+	 */
+	public int getCount(){
+		return songs.size();
+	}
+	
+	/**
+	 * Check whether {@link Song} is not last in playlist
+	 * @param songNumber
+	 * @return true if there is another {@link Song} after specified index
+	 */
+	public boolean hasNext(int songNumber){
+		return songs.size() > (songNumber + 1);
+	}
+	
+	/**
+	 * Check whether {@link Song} with specified index exists in playlist
+	 * @param songNumber
+	 * @return
+	 */
+	public boolean exist(int songNumber){
+		return songs.size() > songNumber;
+	}
+
+	/**
+	 * Returns index of song.
+	 * @param song
+	 * @return Index of song. -1 if song is not in playelist
+	 */
+	public int getIndex(Song song){	return songs.indexOf(song);	}
+
+	/**
+	 * Check whether playlist contains song.
+	 * @param song
+	 * @return
+	 */
+	public boolean contains(Song song) { return songs.contains(song); }
+
+	/**
+	 * Returns list of Songs in Playlist
+	 * @return
+	 */	
+	public ArrayList<Song> getSongList(){
+		return (ArrayList<Song>) songs.clone();
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/RepeatMode.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/RepeatMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..dced462d3c613fa2d07bed8e5159ecec70fdb5d8
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/RepeatMode.java
@@ -0,0 +1,5 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+public enum RepeatMode {
+    NO,ONE,ALL;
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Song.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Song.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab45e017f393cb227076bb71394ba8f3368b4e1e
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Song.java
@@ -0,0 +1,257 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+
+import java.io.File;
+import java.util.HashMap;
+
+/**
+ * Represents a Note Block Studio project
+ *
+ */
+public class Song implements Cloneable {
+
+	private HashMap<Integer, Layer> layerHashMap = new HashMap<Integer, Layer>();
+	private short songHeight;
+	private short length;
+	private String title;
+	private File path;
+	private String author;
+	private String originalAuthor;
+	private String description;
+	private float speed;
+	private float delay;
+	private CustomInstrument[] customInstruments;
+	private int firstCustomInstrumentIndex;
+	private boolean isStereo = false;
+
+	/**
+	 * Create Song instance by copying other Song parameters
+	 * @param other song
+	 */
+	public Song(Song other) {
+		this(other.getSpeed(), other.getLayerHashMap(), other.getSongHeight(), 
+				other.getLength(), other.getTitle(), other.getAuthor(), other.getOriginalAuthor(),
+				other.getDescription(), other.getPath(), other.getFirstCustomInstrumentIndex(), other.getCustomInstruments(), other.isStereo);
+	}
+
+	/**
+	 * @deprecated Use {@link #Song(float, HashMap, short, short, String, String, String, File, int, boolean)}
+	 * @param speed
+	 * @param layerHashMap
+	 * @param songHeight
+	 * @param length
+	 * @param title
+	 * @param author
+	 * @param description
+	 * @param path
+	 */
+	@Deprecated
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path) {
+		this(speed, layerHashMap, songHeight, length, title, author, description, path, InstrumentUtils.getCustomInstrumentFirstIndex(), new CustomInstrument[0], false);
+	}
+
+	/**
+	 * @deprecated Use {@link #Song(float, HashMap, short, short, String, String, String, File, int, CustomInstrument[], boolean)}
+	 * @param speed
+	 * @param layerHashMap
+	 * @param songHeight
+	 * @param length
+	 * @param title
+	 * @param author
+	 * @param description
+	 * @param path
+	 * @param customInstruments
+	 */
+	@Deprecated
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path, CustomInstrument[] customInstruments) {
+		this(speed, layerHashMap, songHeight, length, title, author, description, path, InstrumentUtils.getCustomInstrumentFirstIndex(), customInstruments, false);
+	}
+
+	/**
+	 * @deprecated Use {@link #Song(float, HashMap, short, short, String, String, String, File, int, boolean)}
+	 * @param speed
+	 * @param layerHashMap
+	 * @param songHeight
+	 * @param length
+	 * @param title
+	 * @param author
+	 * @param description
+	 * @param path
+	 * @param firstCustomInstrumentIndex
+	 */
+	@Deprecated
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path, int firstCustomInstrumentIndex) {
+		this(speed, layerHashMap, songHeight, length, title, author, description, path, firstCustomInstrumentIndex, new CustomInstrument[0], false);
+	}
+
+	/**
+	 * @deprecated Use {@link #Song(float, HashMap, short, short, String, String, String, File, int, CustomInstrument[], boolean)}
+	 * @param speed
+	 * @param layerHashMap
+	 * @param songHeight
+	 * @param length
+	 * @param title
+	 * @param author
+	 * @param description
+	 * @param path
+	 * @param firstCustomInstrumentIndex
+	 * @param customInstruments
+	 */
+	@Deprecated
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path, int firstCustomInstrumentIndex, CustomInstrument[] customInstruments) {
+		this(speed, layerHashMap, songHeight, length, title, author, description, path, firstCustomInstrumentIndex, customInstruments, false);
+	}
+
+	@Deprecated
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author,
+				String description, File path, int firstCustomInstrumentIndex, boolean isStereo) {
+		this(speed, layerHashMap, songHeight, length, title, author, "", description, path, firstCustomInstrumentIndex, new CustomInstrument[0], isStereo);
+	}
+
+	@Deprecated
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap, 
+				short songHeight, final short length, String title, String author,
+				String description, File path, int firstCustomInstrumentIndex, CustomInstrument[] customInstruments, boolean isStereo) {
+		this(speed, layerHashMap, songHeight, length, title, author, "", description, path, firstCustomInstrumentIndex, customInstruments, isStereo);
+	}
+
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+				short songHeight, final short length, String title, String author, String originalAuthor,
+				String description, File path, int firstCustomInstrumentIndex, boolean isStereo) {
+		this(speed, layerHashMap, songHeight, length, title, author, originalAuthor, description, path, firstCustomInstrumentIndex, new CustomInstrument[0], isStereo);
+	}
+
+	public Song(float speed, HashMap<Integer, Layer> layerHashMap,
+		short songHeight, final short length, String title, String author, String originalAuthor,
+				String description, File path, int firstCustomInstrumentIndex, CustomInstrument[] customInstruments, boolean isStereo) {
+		this.speed = speed;
+		delay = 20 / speed;
+		this.layerHashMap = layerHashMap;
+		this.songHeight = songHeight;
+		this.length = length;
+		this.title = title;
+		this.author = author;
+		this.originalAuthor = originalAuthor;
+		this.description = description;
+		this.path = path;
+		this.firstCustomInstrumentIndex = firstCustomInstrumentIndex;
+		this.customInstruments = customInstruments;
+		this.isStereo = isStereo;
+	}
+
+	/**
+	 * Gets all Layers in this Song and their index
+	 * @return HashMap of Layers and their index
+	 */
+	public HashMap<Integer, Layer> getLayerHashMap() {
+		return layerHashMap;
+	}
+
+	/**
+	 * Gets the Song's height
+	 * @return Song height
+	 */
+	public short getSongHeight() {
+		return songHeight;
+	}
+
+	/**
+	 * Gets the length in ticks of this Song
+	 * @return length of this Song
+	 */
+	public short getLength() {
+		return length;
+	}
+
+	/**
+	 * Gets the title / name of this Song
+	 * @return title of the Song
+	 */
+	public String getTitle() {
+		return title;
+	}
+
+	/**
+	 * Gets the author of the Song
+	 * @return author
+	 */
+	public String getAuthor() {
+		return author;
+	}
+
+	/**
+	 * Gets the original author of the Song
+	 * @return author
+	 */
+	public String getOriginalAuthor() {
+		return originalAuthor;
+	}
+
+	/**
+	 * Returns the File from which this Song is sourced
+	 * @return file of this Song
+	 */
+	public File getPath() {
+		return path;
+	}
+
+	/**
+	 * Gets the description of this Song
+	 * @return description
+	 */
+	public String getDescription() {
+		return description;
+	}
+
+	/**
+	 * Gets the speed (ticks per second) of this Song
+	 * @return
+	 */
+	public float getSpeed() {
+		return speed;
+	}
+
+	/**
+	 * Gets the delay of this Song
+	 * @return delay
+	 */
+	public float getDelay() {
+		return delay;
+	}
+
+	/**
+	 * Gets the CustomInstruments made for this Song
+	 * @see CustomInstrument
+	 * @return array of CustomInstruments
+	 */
+	public CustomInstrument[] getCustomInstruments() {
+		return customInstruments;
+	}
+
+	@Override
+	public Song clone() {
+		return new Song(this);
+	}
+
+	public int getFirstCustomInstrumentIndex() {
+		return firstCustomInstrumentIndex;
+	}
+
+	/**
+	 * Returns true if song has at least one stereo {@link Note} or {@link Layer} in nbs file
+	 * @return
+	 */
+	public boolean isStereo() {
+		return isStereo;
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Sound.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Sound.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e58870d108d68fbbc2ecfcd6ae23fc4dc4dbcda
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/Sound.java
@@ -0,0 +1,86 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Version independent Spigot sounds.
+ *
+ * Enum mapping to note names for different
+ * Minecraft versions.
+ * 
+ * @see <a href="https://gist.github.com/NiklasEi/7bd0ffd136f8459df0940e4501d47a8a">https://gist.github.com/NiklasEi/7bd0ffd136f8459df0940e4501d47a8a</a>
+ * @author NiklasEi
+ */
+public enum Sound {
+
+	NOTE_PIANO("NOTE_PIANO", "BLOCK_NOTE_HARP", "BLOCK_NOTE_BLOCK_HARP"),
+	NOTE_BASS("NOTE_BASS", "BLOCK_NOTE_BASS", "BLOCK_NOTE_BLOCK_BASS"),
+	NOTE_BASS_DRUM("NOTE_BASS_DRUM", "BLOCK_NOTE_BASEDRUM", "BLOCK_NOTE_BLOCK_BASEDRUM"),
+	NOTE_SNARE_DRUM("NOTE_SNARE_DRUM", "BLOCK_NOTE_SNARE", "BLOCK_NOTE_BLOCK_SNARE"),
+	NOTE_STICKS("NOTE_STICKS", "BLOCK_NOTE_HAT", "BLOCK_NOTE_BLOCK_HAT"),
+	NOTE_BASS_GUITAR("NOTE_BASS_GUITAR", "BLOCK_NOTE_GUITAR", "BLOCK_NOTE_BLOCK_GUITAR"),
+	NOTE_FLUTE("NOTE_FLUTE", "BLOCK_NOTE_FLUTE", "BLOCK_NOTE_BLOCK_FLUTE"),
+	NOTE_BELL("NOTE_BELL", "BLOCK_NOTE_BELL", "BLOCK_NOTE_BLOCK_BELL"),
+	NOTE_CHIME("NOTE_CHIME", "BLOCK_NOTE_CHIME", "BLOCK_NOTE_BLOCK_CHIME"),
+	NOTE_XYLOPHONE("NOTE_XYLOPHONE", "BLOCK_NOTE_XYLOPHONE", "BLOCK_NOTE_BLOCK_XYLOPHONE"),
+	NOTE_PLING("NOTE_PLING", "BLOCK_NOTE_PLING", "BLOCK_NOTE_BLOCK_PLING"),
+	NOTE_IRON_XYLOPHONE("BLOCK_NOTE_BLOCK_IRON_XYLOPHONE"),
+	NOTE_COW_BELL("BLOCK_NOTE_BLOCK_COW_BELL"),
+	NOTE_DIDGERIDOO("BLOCK_NOTE_BLOCK_DIDGERIDOO"),
+	NOTE_BIT("BLOCK_NOTE_BLOCK_BIT"),
+	NOTE_BANJO("BLOCK_NOTE_BLOCK_BANJO");
+
+	private String[] versionDependentNames;
+	private org.bukkit.Sound cached = null;
+	private static Map<String, org.bukkit.Sound> cachedSoundMap = new HashMap<>();
+
+	Sound(String... versionDependentNames) {
+		this.versionDependentNames = versionDependentNames;
+	}
+
+	/**
+	 * Attempts to retrieve the org.bukkit.Sound equivalent of a version dependent enum name
+	 * @param bukkitSoundName
+	 * @return org.bukkit.Sound enum
+	 */
+	public static org.bukkit.Sound getFromBukkitName(String bukkitSoundName) {
+		org.bukkit.Sound sound = cachedSoundMap.get(bukkitSoundName.toUpperCase());
+		if (sound != null)
+			return sound;
+
+		return org.bukkit.Sound.valueOf(bukkitSoundName);
+	}
+
+	private org.bukkit.Sound getSound() {
+		if (cached != null) return cached;
+		for (String name : versionDependentNames) {
+			try {
+				return cached = org.bukkit.Sound.valueOf(name);
+			} catch (IllegalArgumentException ignore2) {
+				// try next
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Get the bukkit sound for current server version
+	 *
+	 * Caches sound on first call
+	 * @return corresponding {@link org.bukkit.Sound}
+	 */
+	public org.bukkit.Sound bukkitSound() {
+		if (getSound() != null) {
+			return getSound();
+		}
+		throw new IllegalArgumentException("Found no valid sound name for " + this.name());
+	}
+
+	static {
+		// Cache sound access.
+		for (Sound sound : values())
+			for (String soundName : sound.versionDependentNames)
+				cachedSoundMap.put(soundName.toUpperCase(), sound.getSound());
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/SoundCategory.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/SoundCategory.java
new file mode 100644
index 0000000000000000000000000000000000000000..21a5088c0106644a876bcec548a51cea85862dc1
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/SoundCategory.java
@@ -0,0 +1,20 @@
+package com.xxmicloxx.NoteBlockAPI.model;
+
+/**
+
+ *
+ */
+public enum SoundCategory {
+
+	MASTER,
+	MUSIC,
+	RECORDS,
+	WEATHER,
+	BLOCKS,
+	HOSTILE,
+	NEUTRAL,
+	PLAYERS,
+	AMBIENT,
+	VOICE;
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/ChannelMode.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/ChannelMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..80717341dbcca79ade19edcca1d05a5963f6e565
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/ChannelMode.java
@@ -0,0 +1,21 @@
+package com.xxmicloxx.NoteBlockAPI.model.playmode;
+
+import com.xxmicloxx.NoteBlockAPI.model.Layer;
+import com.xxmicloxx.NoteBlockAPI.model.Note;
+import com.xxmicloxx.NoteBlockAPI.model.Song;
+import com.xxmicloxx.NoteBlockAPI.model.SoundCategory;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+/**
+ * Decides how is {@link Note} played to {@link Player}
+ */
+public abstract class ChannelMode {
+
+    @Deprecated
+    public abstract void play(Player player, Location location, Song song, Layer layer, Note note,
+                              SoundCategory soundCategory, float volume, float pitch);
+
+    public abstract void play(Player player, Location location, Song song, Layer layer, Note note,
+                              SoundCategory soundCategory, float volume, boolean doTranspose);
+}
\ No newline at end of file
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/MonoMode.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/MonoMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..2044a38d2b141758c2483a22fa945d5916cdffc8
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/MonoMode.java
@@ -0,0 +1,59 @@
+package com.xxmicloxx.NoteBlockAPI.model.playmode;
+
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils;
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+import com.xxmicloxx.NoteBlockAPI.utils.NoteUtils;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+/**
+ * {@link Note} is played inside of {@link Player}'s head.
+ */
+public class MonoMode extends ChannelMode {
+
+    @Override
+    public void play(Player player, Location location, Song song, Layer layer, Note note, SoundCategory soundCategory, float volume, float pitch) {
+        if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+            CustomInstrument instrument = song.getCustomInstruments()[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+            if (instrument.getSound() != null) {
+                CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, 0);
+            } else {
+                CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, 0);
+            }
+        } else {
+            CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, 0);
+        }
+    }
+
+    @Override
+    public void play(Player player, Location location, Song song, Layer layer, Note note, SoundCategory soundCategory, float volume, boolean doTranspose) {
+        float pitch;
+        if(doTranspose)
+            pitch = NoteUtils.getPitchTransposed(note);
+        else
+            pitch = NoteUtils.getPitchInOctave(note);
+        if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+            CustomInstrument instrument = song.getCustomInstruments()[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+            if (!doTranspose){
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(instrument.getSoundFileName(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, 0);
+            } else {
+                if (instrument.getSound() != null) {
+                    CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, 0);
+                } else {
+                    CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, 0);
+                }
+            }
+
+        } else {
+            if (NoteUtils.isOutOfRange(note.getKey(), note.getPitch()) && !doTranspose) {
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(note.getInstrument(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, 0);
+            }
+            else {
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, 0);
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/MonoStereoMode.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/MonoStereoMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..bbbd4abc648e31057e94193bd6ac30617bcc2783
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/MonoStereoMode.java
@@ -0,0 +1,84 @@
+package com.xxmicloxx.NoteBlockAPI.model.playmode;
+
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils;
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+import com.xxmicloxx.NoteBlockAPI.utils.NoteUtils;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+/**
+ * Ignores panning of {@link Note} and {@link Layer} from nbs format and plays mono {@link Note} as fake stereo at fixed offset from {@link Player} head.
+ */
+public class MonoStereoMode extends ChannelMode{
+
+    private float distance = 2;
+
+    @Override
+    public void play(Player player, Location location, Song song, Layer layer, Note note, SoundCategory soundCategory, float volume, float pitch) {
+        if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+            CustomInstrument instrument = song.getCustomInstruments()[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+            if (instrument.getSound() != null) {
+                CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, distance);
+                CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, -distance);
+            } else {
+                CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, distance);
+                CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, -distance);
+            }
+        } else {
+            CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, distance);
+            CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, -distance);
+        }
+    }
+
+    @Override
+    public void play(Player player, Location location, Song song, Layer layer, Note note, SoundCategory soundCategory, float volume, boolean doTranspose) {
+        float pitch;
+        if(doTranspose)
+            pitch = NoteUtils.getPitchTransposed(note);
+        else
+            pitch = NoteUtils.getPitchInOctave(note);
+
+        if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+            CustomInstrument instrument = song.getCustomInstruments()[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+            if (!doTranspose){
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(instrument.getSoundFileName(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, distance);
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(instrument.getSoundFileName(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, -distance);
+            } else {
+                if (instrument.getSound() != null) {
+                    CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, distance);
+                    CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, -distance);
+                } else {
+                    CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, distance);
+                    CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, -distance);
+                }
+            }
+        } else {
+            if (NoteUtils.isOutOfRange(note.getKey(), note.getPitch()) && !doTranspose) {
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(note.getInstrument(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, distance);
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(note.getInstrument(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, -distance);
+            } else {
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, distance);
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, -distance);
+            }
+        }
+    }
+
+    /**
+     * Returns distance of {@link Note} from {@link Player}'s head.
+     * @return
+     */
+    public float getDistance() {
+        return distance;
+    }
+
+    /**
+     * Sets distance of {@link Note} from {@link Player}'s head.
+     * @param distance
+     */
+    public void setDistance(float distance) {
+        this.distance = distance;
+    }
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/StereoMode.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/StereoMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..fbcb73c240ceaf57c0f26f9aca07eabcc6d1ca67
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/model/playmode/StereoMode.java
@@ -0,0 +1,118 @@
+package com.xxmicloxx.NoteBlockAPI.model.playmode;
+
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils;
+import com.xxmicloxx.NoteBlockAPI.utils.InstrumentUtils;
+import com.xxmicloxx.NoteBlockAPI.utils.NoteUtils;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+/**
+ * Uses panning for individual {@link Note} and {@link Layer} based on data from nbs file.
+ */
+public class StereoMode extends ChannelMode {
+
+    private float maxDistance = 2;
+    private ChannelMode fallbackChannelMode = null;
+
+    @Override
+    public void play(Player player, Location location, Song song, Layer layer, Note note, SoundCategory soundCategory, float volume, float pitch) {
+        if (!song.isStereo() && fallbackChannelMode != null){
+            fallbackChannelMode.play(player, location, song, layer, note, soundCategory, volume, pitch);
+            return;
+        }
+
+        float distance = 0;
+        if (layer.getPanning() == 100){
+            distance = ((note.getPanning() - 100) / 100f) * maxDistance;
+        } else {
+            distance = ((layer.getPanning() - 100 + note.getPanning() - 100) / 200f) * maxDistance;
+        }
+        if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+            CustomInstrument instrument = song.getCustomInstruments()[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+            if (instrument.getSound() != null) {
+                CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, distance);
+            } else {
+                CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, distance);
+            }
+        } else {
+            CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, distance);
+        }
+    }
+
+    @Override
+    public void play(Player player, Location location, Song song, Layer layer, Note note, SoundCategory soundCategory, float volume, boolean doTranspose) {
+        if (!song.isStereo() && fallbackChannelMode != null){
+            fallbackChannelMode.play(player, location, song, layer, note, soundCategory, volume, doTranspose);
+            return;
+        }
+
+        float pitch;
+        if(doTranspose)
+            pitch = NoteUtils.getPitchTransposed(note);
+        else
+            pitch = NoteUtils.getPitchInOctave(note);
+
+        float distance = 0;
+        if (layer.getPanning() == 100){
+            distance = ((note.getPanning() - 100) / 100f) * maxDistance;
+        } else {
+            distance = ((layer.getPanning() - 100 + note.getPanning() - 100) / 200f) * maxDistance;
+        }
+        if (InstrumentUtils.isCustomInstrument(note.getInstrument())) {
+            CustomInstrument instrument = song.getCustomInstruments()[note.getInstrument() - InstrumentUtils.getCustomInstrumentFirstIndex()];
+
+            if (!doTranspose){
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(instrument.getSoundFileName(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, distance);
+            } else {
+                if (instrument.getSound() != null) {
+                    CompatibilityUtils.playSound(player, location, instrument.getSound(), soundCategory, volume, pitch, distance);
+                } else {
+                    CompatibilityUtils.playSound(player, location, instrument.getSoundFileName(), soundCategory, volume, pitch, distance);
+                }
+            }
+        } else {
+            if (NoteUtils.isOutOfRange(note.getKey(), note.getPitch()) && !doTranspose) {
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.warpNameOutOfRange(note.getInstrument(), note.getKey(), note.getPitch()), soundCategory, volume, pitch, distance);
+            } else {
+                CompatibilityUtils.playSound(player, location, InstrumentUtils.getInstrument(note.getInstrument()), soundCategory, volume, pitch, distance);
+            }
+        }
+    }
+
+    /**
+     * Returns scale of panning in blocks. {@link Note} with maximum left panning will be played this distance from {@link Player}'s head on left side.
+     * @return
+     */
+    public float getMaxDistance() {
+        return maxDistance;
+    }
+
+    /**
+     * Sets scale of panning in blocks. {@link Note} with maximum left panning will be played this distance from {@link Player}'s head on left side.
+     * @param maxDistance
+     */
+    public void setMaxDistance(float maxDistance) {
+        this.maxDistance = maxDistance;
+    }
+
+    /**
+     * Returns fallback {@link ChannelMode} used when song is not stereo.
+     * @return ChannelMode or null when fallback ChannelMode is disabled
+     */
+    public ChannelMode getFallbackChannelMode() {
+        return fallbackChannelMode;
+    }
+
+    /**
+     * Sets fallback {@link ChannelMode} which is used when song is not stereo. Set to null to disable.
+     * @param fallbackChannelMode
+     * @throws IllegalArgumentException if parameter is instance of StereoMode
+     */
+    public void setFallbackChannelMode(ChannelMode fallbackChannelMode) {
+        if (fallbackChannelMode instanceof StereoMode) throw new IllegalArgumentException("Fallback ChannelMode can't be instance of StereoMode!");
+
+        this.fallbackChannelMode = fallbackChannelMode;
+    }
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/EntitySongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/EntitySongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..37b26d8a6c2a90cc763804fb6abee9e17dd2e78f
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/EntitySongPlayer.java
@@ -0,0 +1,93 @@
+package com.xxmicloxx.NoteBlockAPI.songplayer;
+
+import com.xxmicloxx.NoteBlockAPI.NoteBlockAPI;
+import com.xxmicloxx.NoteBlockAPI.event.PlayerRangeStateChangeEvent;
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+
+public class EntitySongPlayer extends RangeSongPlayer {
+
+    private Entity entity;
+
+    public EntitySongPlayer(Song song) {
+        super(song);
+    }
+
+    public EntitySongPlayer(Song song, SoundCategory soundCategory) {
+        super(song, soundCategory);
+    }
+
+    public EntitySongPlayer(Playlist playlist, SoundCategory soundCategory) {
+        super(playlist, soundCategory);
+    }
+
+    public EntitySongPlayer(Playlist playlist) {
+        super(playlist);
+    }
+
+    /**
+     * Returns true if the Player is able to hear the current {@link EntitySongPlayer}
+     * @param player in range
+     * @return ability to hear the current {@link EntitySongPlayer}
+     */
+    @Override
+    public boolean isInRange(Player player) {
+        return player.getLocation().distance(entity.getLocation()) <= getDistance();
+    }
+
+    /**
+     * Set entity associated with this {@link EntitySongPlayer}
+     * @param entity
+     */
+    public void setEntity(Entity entity){
+        this.entity = entity;
+    }
+
+    /**
+     * Get {@link Entity} associated with this {@link EntitySongPlayer}
+     * @return
+     */
+    public Entity getEntity() {
+        return entity;
+    }
+
+    @Override
+    public void playTick(Player player, int tick) {
+        if (entity.isDead()){
+            if (autoDestroy){
+                destroy();
+            } else {
+                setPlaying(false);
+            }
+        }
+        if (!player.getWorld().getName().equals(entity.getWorld().getName())) {
+            return; // not in same world
+        }
+
+        byte playerVolume = NoteBlockAPI.getPlayerVolume(player);
+
+        for (Layer layer : song.getLayerHashMap().values()) {
+            Note note = layer.getNote(tick);
+            if (note == null) continue;
+
+            float volume = ((layer.getVolume() * (int) this.volume * (int) playerVolume * note.getVelocity()) / 100_00_00_00F)
+                    * ((1F / 16F) * getDistance());
+
+            channelMode.play(player, entity.getLocation(), song, layer, note, soundCategory, volume, !enable10Octave);
+
+            if (isInRange(player)) {
+                if (!playerList.get(player.getUniqueId())) {
+                    playerList.put(player.getUniqueId(), true);
+                    Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, true));
+                }
+            } else {
+                if (playerList.get(player.getUniqueId())) {
+                    playerList.put(player.getUniqueId(), false);
+                    Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, false));
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/Fade.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/Fade.java
new file mode 100644
index 0000000000000000000000000000000000000000..3bd19b4d4123204a25877c911254051345b30d73
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/Fade.java
@@ -0,0 +1,99 @@
+package com.xxmicloxx.NoteBlockAPI.songplayer;
+
+import com.xxmicloxx.NoteBlockAPI.model.FadeType;
+import com.xxmicloxx.NoteBlockAPI.utils.Interpolator;
+
+public class Fade {
+
+	private FadeType type;
+	private byte fadeStart;
+	private byte fadeTarget;
+	private int fadeDuration;
+	private int fadeDone = 0;
+	
+	/**
+	 * Create new fade effect
+	 * @param type Type of fade effect
+	 * @param fadeDuration - duration of fade effect in ticks
+	 */
+	public Fade(FadeType type, int fadeDuration){
+		this.type = type;
+		this.fadeDuration = fadeDuration;
+	}
+	
+	protected byte calculateFade() {
+		switch (type){
+			case LINEAR:
+				if (fadeDone == fadeDuration) {
+					return -1; // no fade today
+				}
+				double targetVolume = Interpolator.interpLinear(
+						new double[]{0, fadeStart, fadeDuration, fadeTarget}, fadeDone);
+				fadeDone++;
+				return (byte) targetVolume;
+			default:
+				fadeDone++;
+				return -1;
+		}
+	}
+
+	protected int getFadeDone() {
+		return fadeDone;
+	}
+
+	protected void setFadeStart(byte fadeStart) {
+		this.fadeStart = fadeStart;
+	}
+
+	protected void setFadeTarget(byte fadeTarget) {
+		this.fadeTarget = fadeTarget;
+	}
+
+	/**
+	 * Returns fade effect type
+	 * @return {@link FadeType}
+	 */
+	public FadeType getType() {
+		return type;
+	}
+
+	/**
+	 * Set fade effect type
+	 * @param type FadeType
+	 */
+	public void setType(FadeType type) {
+		this.type = type;
+	}
+
+	/**
+	 * Returns duration of fade effect
+	 * @return duration in ticks
+	 */
+	public int getFadeDuration() {
+		return fadeDuration;
+	}
+
+	/**
+	 * Set fade effect duration
+	 * @param fadeDuration duration in ticks
+	 */
+	public void setFadeDuration(int fadeDuration) {
+		this.fadeDuration = fadeDuration;
+	}
+
+	protected byte getFadeStart() {
+		return fadeStart;
+	}
+
+	protected byte getFadeTarget() {
+		return fadeTarget;
+	}
+	
+	protected void setFadeDone(int fadeDone){
+		this.fadeDone = fadeDone;
+	}
+
+	public boolean isDone(){
+	    return fadeDone >= fadeDuration;
+    }
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/NoteBlockSongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/NoteBlockSongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..30c0133903f4ed1701cb426ea093232c1365dae5
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/NoteBlockSongPlayer.java
@@ -0,0 +1,125 @@
+package com.xxmicloxx.NoteBlockAPI.songplayer;
+
+import com.xxmicloxx.NoteBlockAPI.NoteBlockAPI;
+import com.xxmicloxx.NoteBlockAPI.SongPlayer;
+import com.xxmicloxx.NoteBlockAPI.event.PlayerRangeStateChangeEvent;
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import com.xxmicloxx.NoteBlockAPI.utils.CompatibilityUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Player;
+
+/**
+ * SongPlayer created at a specified NoteBlock
+ *
+ */
+public class NoteBlockSongPlayer extends RangeSongPlayer {
+
+	private Block noteBlock;
+
+	public NoteBlockSongPlayer(Song song) {
+		super(song);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.NoteBlockSongPlayer.class);
+	}
+
+	public NoteBlockSongPlayer(Song song, SoundCategory soundCategory) {
+		super(song, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.NoteBlockSongPlayer.class);
+	}
+
+	public NoteBlockSongPlayer(Playlist playlist, SoundCategory soundCategory) {
+		super(playlist, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.NoteBlockSongPlayer.class);
+	}
+
+	public NoteBlockSongPlayer(Playlist playlist) {
+		super(playlist);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.NoteBlockSongPlayer.class);
+	}
+
+	private NoteBlockSongPlayer(SongPlayer songPlayer) {
+		super(songPlayer);
+	}
+	
+	@Override
+	void update(String key, Object value) {
+		super.update(key, value);
+		
+		switch (key){
+			case "noteBlock":
+				noteBlock = (Block) value;
+				break;
+		}
+	}
+
+	/**
+	 * Get the Block this SongPlayer is played at
+	 * @return Block representing a NoteBlock
+	 */
+	public Block getNoteBlock() {
+		return noteBlock;
+	}
+
+	/**
+	 * Set the Block this SongPlayer is played at
+	 */
+	public void setNoteBlock(Block noteBlock) {
+		this.noteBlock = noteBlock;
+		CallUpdate("noteBlock", noteBlock);
+	}
+
+	@Override
+	public void playTick(Player player, int tick) {
+		if (noteBlock.getType() != CompatibilityUtils.getNoteBlockMaterial()) {
+			return;
+		}
+		if (!player.getWorld().getName().equals(noteBlock.getWorld().getName())) {
+			// not in same world
+			return;
+		}
+		byte playerVolume = NoteBlockAPI.getPlayerVolume(player);
+		Location loc = noteBlock.getLocation();
+		loc = new Location(loc.getWorld(), loc.getX() + 0.5f, loc.getY() - 0.5f, loc.getZ() + 0.5f);
+		
+		for (Layer layer : song.getLayerHashMap().values()) {
+			Note note = layer.getNote(tick);
+			if (note == null) {
+				continue;
+			}
+
+			float volume = ((layer.getVolume() * (int) this.volume * (int) playerVolume * note.getVelocity()) / 100_00_00_00F)
+					* ((1F / 16F) * getDistance());
+
+            channelMode.play(player, loc, song, layer, note, soundCategory, volume, !enable10Octave);
+
+			if (isInRange(player)) {
+				if (!this.playerList.get(player.getUniqueId())) {
+					playerList.put(player.getUniqueId(), true);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, true));
+				}
+			} else {
+				if (this.playerList.get(player.getUniqueId())) {
+					playerList.put(player.getUniqueId(), false);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, false));
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Returns true if the Player is able to hear the current NoteBlockSongPlayer 
+	 * @param player in range
+	 * @return ability to hear the current NoteBlockSongPlayer
+	 */	
+	@Override
+	public boolean isInRange(Player player) {
+		Location loc = noteBlock.getLocation();
+		loc = new Location(loc.getWorld(), loc.getX() + 0.5f, loc.getY() - 0.5f, loc.getZ() + 0.5f);
+		if (player.getLocation().distance(loc) > getDistance()) {
+			return false;
+		} else {
+			return true;
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/PositionSongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/PositionSongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a2ebc9e3558c921ccaa6518b674dbc6c954b5ec
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/PositionSongPlayer.java
@@ -0,0 +1,110 @@
+package com.xxmicloxx.NoteBlockAPI.songplayer;
+
+import com.xxmicloxx.NoteBlockAPI.NoteBlockAPI;
+import com.xxmicloxx.NoteBlockAPI.SongPlayer;
+import com.xxmicloxx.NoteBlockAPI.event.PlayerRangeStateChangeEvent;
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+/**
+ * SongPlayer created at a specified Location
+ *
+ */
+public class PositionSongPlayer extends RangeSongPlayer {
+
+	private Location targetLocation;
+
+	public PositionSongPlayer(Song song) {
+		super(song);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.PositionSongPlayer.class);
+	}
+
+	public PositionSongPlayer(Song song, SoundCategory soundCategory) {
+		super(song, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.PositionSongPlayer.class);
+	}
+	
+	private PositionSongPlayer(SongPlayer songPlayer) {
+		super(songPlayer);
+	}
+	
+	public PositionSongPlayer(Playlist playlist, SoundCategory soundCategory) {
+		super(playlist, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.PositionSongPlayer.class);
+	}
+
+	public PositionSongPlayer(Playlist playlist) {
+		super(playlist);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.PositionSongPlayer.class);
+	}
+
+	@Override
+	void update(String key, Object value) {
+		super.update(key, value);
+		
+		switch (key){
+			case "targetLocation":
+				targetLocation = (Location) value;
+				break;
+		}
+	}
+
+	/**
+	 * Gets location on which is the PositionSongPlayer playing
+	 * @return {@link Location}
+	 */
+	public Location getTargetLocation() {
+		return targetLocation;
+	}
+
+	/**
+	 * Sets location on which is the PositionSongPlayer playing
+	 */
+	public void setTargetLocation(Location targetLocation) {
+		this.targetLocation = targetLocation;
+		CallUpdate("targetLocation", targetLocation);
+	}
+
+	@Override
+	public void playTick(Player player, int tick) {
+		if (!player.getWorld().getName().equals(targetLocation.getWorld().getName())) {
+			return; // not in same world
+		}
+
+		byte playerVolume = NoteBlockAPI.getPlayerVolume(player);
+
+		for (Layer layer : song.getLayerHashMap().values()) {
+			Note note = layer.getNote(tick);
+			if (note == null) continue;
+
+			float volume = ((layer.getVolume() * (int) this.volume * (int) playerVolume * note.getVelocity()) / 100_00_00_00F)
+					* ((1F / 16F) * getDistance());
+
+			channelMode.play(player, targetLocation, song, layer, note, soundCategory, volume, !enable10Octave);
+
+			if (isInRange(player)) {
+				if (!playerList.get(player.getUniqueId())) {
+					playerList.put(player.getUniqueId(), true);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, true));
+				}
+			} else {
+				if (playerList.get(player.getUniqueId())) {
+					playerList.put(player.getUniqueId(), false);
+					Bukkit.getPluginManager().callEvent(new PlayerRangeStateChangeEvent(this, player, false));
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Returns true if the Player is able to hear the current PositionSongPlayer 
+	 * @param player in range
+	 * @return ability to hear the current PositionSongPlayer
+	 */
+	@Override
+	public boolean isInRange(Player player) {
+		return player.getLocation().distance(targetLocation) <= getDistance();
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/RadioSongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/RadioSongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb1148fd611d157369886f64a94cf6db489c0871
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/RadioSongPlayer.java
@@ -0,0 +1,85 @@
+package com.xxmicloxx.NoteBlockAPI.songplayer;
+
+import com.xxmicloxx.NoteBlockAPI.NoteBlockAPI;
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import com.xxmicloxx.NoteBlockAPI.model.playmode.ChannelMode;
+import com.xxmicloxx.NoteBlockAPI.model.playmode.MonoMode;
+import com.xxmicloxx.NoteBlockAPI.model.playmode.MonoStereoMode;
+import org.bukkit.entity.Player;
+
+/**
+ * SongPlayer playing to everyone added to it no matter where he is
+ *
+ */
+public class RadioSongPlayer extends SongPlayer {
+	
+	//protected boolean stereo = true;
+	
+	public RadioSongPlayer(Song song) {
+		super(song);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.RadioSongPlayer.class);
+	}
+
+	public RadioSongPlayer(Song song, SoundCategory soundCategory) {
+		super(song, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.RadioSongPlayer.class);
+	}
+
+	private RadioSongPlayer(com.xxmicloxx.NoteBlockAPI.SongPlayer songPlayer) {
+		super(songPlayer);
+	}
+
+	public RadioSongPlayer(Playlist playlist, SoundCategory soundCategory) {
+		super(playlist, soundCategory);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.RadioSongPlayer.class);
+	}
+
+	public RadioSongPlayer(Playlist playlist) {
+		super(playlist);
+		makeNewClone(com.xxmicloxx.NoteBlockAPI.RadioSongPlayer.class);
+	}
+
+	@Override
+	public void playTick(Player player, int tick) {
+		byte playerVolume = NoteBlockAPI.getPlayerVolume(player);
+
+		for (Layer layer : song.getLayerHashMap().values()) {
+			Note note = layer.getNote(tick);
+			if (note == null) {
+				continue;
+			}
+
+			float volume = (layer.getVolume() * (int) this.volume * (int) playerVolume * note.getVelocity()) / 100_00_00_00F;
+
+			channelMode.play(player, player.getEyeLocation(), song, layer, note, soundCategory, volume, !enable10Octave);
+		}
+	}
+
+	/**
+	 * Returns if the SongPlayer will play Notes from two sources as stereo
+	 * @return if is played stereo
+     * @deprecated
+	 */
+	@Deprecated
+	public boolean isStereo(){
+		return !(channelMode instanceof MonoMode);
+	}
+	
+	/**
+	 * Sets if the SongPlayer will play Notes from two sources as stereo
+	 * @param stereo
+     * @deprecated
+	 */
+	@Deprecated
+	public void setStereo(boolean stereo){
+		channelMode = stereo ? new MonoMode() : new MonoStereoMode();
+	}
+
+	/**
+	 * Sets how will be {@link Note} played to {@link Player} (eg. mono or stereo). Default is {@link MonoMode}.
+	 * @param mode
+	 */
+	public void setChannelMode(ChannelMode mode){
+	    channelMode = mode;
+    }
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/RangeSongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/RangeSongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b1e8d42b2ee9127723bf4fa5d669b3c6c527d22
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/RangeSongPlayer.java
@@ -0,0 +1,67 @@
+package com.xxmicloxx.NoteBlockAPI.songplayer;
+
+import com.xxmicloxx.NoteBlockAPI.model.Playlist;
+import com.xxmicloxx.NoteBlockAPI.model.Song;
+import com.xxmicloxx.NoteBlockAPI.model.SoundCategory;
+import org.bukkit.entity.Player;
+
+/**
+ * SongPlayer playing only in specified distance
+ *
+ */
+public abstract class RangeSongPlayer extends SongPlayer{
+
+	private int distance = 16;
+	
+	public RangeSongPlayer(Song song, SoundCategory soundCategory) {
+		super(song, soundCategory);
+	}
+
+	public RangeSongPlayer(Song song) {
+		super(song);
+	}	
+
+	protected RangeSongPlayer(com.xxmicloxx.NoteBlockAPI.SongPlayer songPlayer) {
+		super(songPlayer);
+	}
+
+	public RangeSongPlayer(Playlist playlist, SoundCategory soundCategory) {
+		super(playlist, soundCategory);
+	}
+
+	public RangeSongPlayer(Playlist playlist) {
+		super(playlist);
+	}
+
+	@Override
+	void update(String key, Object value) {
+		super.update(key, value);
+		
+		switch (key){
+			case "distance":
+				distance = (int) value;
+				break;
+		}
+	}
+
+	/**
+	 * Sets distance in blocks where would be player able to hear sound. 
+	 * @param distance (Default 16 blocks)
+	 */
+	public void setDistance(int distance) {
+		this.distance = distance;
+		CallUpdate("distance", distance);
+	}
+
+	public int getDistance() {
+		return distance;
+	}
+	
+	/**
+	 * Returns true if the Player is able to hear the current RangeSongPlayer 
+	 * @param player in range
+	 * @return ability to hear the current RangeSongPlayer
+	 */
+	public abstract boolean isInRange(Player player);
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/SongPlayer.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/SongPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f4424e6f5a6256757bfeff6b37ea560d9f72f44
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/songplayer/SongPlayer.java
@@ -0,0 +1,917 @@
+package com.xxmicloxx.NoteBlockAPI.songplayer;
+
+import com.xxmicloxx.NoteBlockAPI.NoteBlockAPI;
+import com.xxmicloxx.NoteBlockAPI.event.*;
+import com.xxmicloxx.NoteBlockAPI.model.*;
+import com.xxmicloxx.NoteBlockAPI.model.playmode.ChannelMode;
+import com.xxmicloxx.NoteBlockAPI.model.playmode.MonoMode;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+
+/**
+ * Plays a Song for a list of Players
+ *
+ */
+public abstract class SongPlayer {
+
+	protected Song song;
+	protected Playlist playlist;
+	protected int actualSong = 0;
+
+	protected boolean playing = false;
+	protected boolean fading = false;
+	protected short tick = -1;
+	protected Map<UUID, Boolean> playerList = new ConcurrentHashMap<UUID, Boolean>();
+
+	protected boolean autoDestroy = false;
+	protected boolean destroyed = false;
+
+	protected byte volume = 100;
+	protected Fade fadeIn;
+	protected Fade fadeOut;
+	protected Fade fadeTemp = null;
+	protected RepeatMode repeat = RepeatMode.NO;
+	protected boolean random = false;
+
+	protected Map<Song, Boolean> songQueue = new ConcurrentHashMap<Song, Boolean>(); //True if already played
+
+	private final Lock lock = new ReentrantLock();
+	private final Random rng = new Random();
+
+	protected NoteBlockAPI plugin;
+
+	protected SoundCategory soundCategory;
+	protected ChannelMode channelMode = new MonoMode();
+	protected boolean enable10Octave = false;
+
+	com.xxmicloxx.NoteBlockAPI.SongPlayer oldSongPlayer;
+
+	public SongPlayer(Song song) {
+		this(new Playlist(song), SoundCategory.MASTER);
+	}
+
+	public SongPlayer(Song song, SoundCategory soundCategory) {
+		this(new Playlist(song), soundCategory);
+	}
+
+	public SongPlayer(Song song, SoundCategory soundCategory, boolean random) {
+		this(new Playlist(song), soundCategory, random);
+	}
+	
+	public SongPlayer(Playlist playlist){
+		this(playlist, SoundCategory.MASTER);
+	}
+
+	public SongPlayer(Playlist playlist, SoundCategory soundCategory){
+		this(playlist, soundCategory, false);
+	}
+
+	public SongPlayer(Playlist playlist, SoundCategory soundCategory, boolean random){
+		this.playlist = playlist;
+		this.random = random;
+		this.soundCategory = soundCategory;
+		plugin = NoteBlockAPI.getAPI();
+		
+		fadeIn = new Fade(FadeType.NONE, 60);
+		fadeIn.setFadeStart((byte) 0);
+		fadeIn.setFadeTarget(volume);
+		
+		fadeOut = new Fade(FadeType.NONE, 60);
+		fadeOut.setFadeStart(volume);
+		fadeOut.setFadeTarget((byte) 0);
+
+		if (random){
+			checkPlaylistQueue();
+			actualSong = rng.nextInt(playlist.getCount());
+		}
+		this.song = playlist.get(actualSong);
+
+		start();
+	}
+
+	/**
+	 * @deprecated
+	 * @param songPlayer
+	 */
+	SongPlayer(com.xxmicloxx.NoteBlockAPI.SongPlayer songPlayer){
+		oldSongPlayer = songPlayer;
+		com.xxmicloxx.NoteBlockAPI.Song s = songPlayer.getSong();
+		HashMap<Integer, Layer> layerHashMap = new HashMap<Integer, Layer>();
+		for (Integer i : s.getLayerHashMap().keySet()){
+			com.xxmicloxx.NoteBlockAPI.Layer l = s.getLayerHashMap().get(i);
+			HashMap<Integer, Note> noteHashMap = new HashMap<Integer, Note>();
+			for (Integer iL : l.getHashMap().keySet()){
+				com.xxmicloxx.NoteBlockAPI.Note note = l.getHashMap().get(iL);
+				noteHashMap.put(iL, new Note(note.getInstrument(), note.getKey()));
+			}
+			Layer layer = new Layer();
+			layer.setNotesAtTicks(noteHashMap);
+			layer.setVolume(l.getVolume());
+			layerHashMap.put(i, layer);
+		}
+		CustomInstrument[] instruments = new CustomInstrument[s.getCustomInstruments().length];
+		for (int i = 0; i < s.getCustomInstruments().length; i++){
+			com.xxmicloxx.NoteBlockAPI.CustomInstrument ci = s.getCustomInstruments()[i];
+			instruments[i] = new CustomInstrument(ci.getIndex(), ci.getName(), ci.getSoundfile());
+		}
+		song = new Song(s.getSpeed(), layerHashMap, s.getSongHeight(), s.getLength(), s.getTitle(), s.getAuthor(), s.getDescription(), s.getPath(), instruments);
+		playlist = new Playlist(song);
+		
+		fadeIn = new Fade(FadeType.NONE, 60);
+		fadeIn.setFadeStart((byte) 0);
+		fadeIn.setFadeTarget(volume);
+		
+		fadeOut = new Fade(FadeType.NONE, 60);
+		fadeOut.setFadeStart(volume);
+		fadeOut.setFadeTarget((byte) 0);
+
+		plugin = NoteBlockAPI.getAPI();
+	}
+
+	void update(String key, Object value){
+		switch (key){
+			case "playing":
+				playing = (boolean) value;
+				break;
+			case "fadeType":
+				fadeIn.setType(FadeType.valueOf(((String) value).replace("FADE_", "")));
+				break;
+			case "fadeTarget":
+				fadeIn.setFadeTarget((byte) value);
+				break;
+			case "fadeStart":
+				fadeIn.setFadeStart((byte) value);
+				break;
+			case "fadeDuration":
+				fadeIn.setFadeDuration((int) value);
+				break;
+			case "fadeDone":
+				fadeIn.setFadeDone((int) value);
+				break;
+			case "tick":
+				tick = (short) value;
+				break;
+			case "addplayer":
+				addPlayer(((Player) value).getUniqueId(), false);
+				break;
+			case "removeplayer":
+				removePlayer(((Player) value).getUniqueId(), false);
+				break;
+			case "autoDestroy":
+				autoDestroy = (boolean) value;
+				break;
+			case "volume":
+				volume = (byte) value;
+				break;
+			case "soundCategory":
+				soundCategory = SoundCategory.valueOf((String) value);
+				break;
+				
+		}
+	}
+	
+	/**
+	 * Gets the FadeType for this SongPlayer (unused)
+	 * @return FadeType
+	 * @deprecated returns fadeIn value
+	 */
+	@Deprecated
+	public FadeType getFadeType() {
+		return fadeIn.getType();
+	}
+
+	/**
+	 * Sets the FadeType for this SongPlayer
+	 * @param fadeType
+	 * @deprecated set fadeIn value
+	 */
+	@Deprecated
+	public void setFadeType(FadeType fadeType) {
+		fadeIn.setType(fadeType);
+		CallUpdate("fadetype", "FADE_" + fadeType.name());
+	}
+
+	/**
+	 * Target volume for fade
+	 * @return byte representing fade target
+	 * @deprecated returns fadeIn value
+	 */
+	@Deprecated
+	public byte getFadeTarget() {
+		return fadeIn.getFadeTarget();
+	}
+
+	/**
+	 * Set target volume for fade
+	 * @param fadeTarget
+	 * @deprecated set fadeIn value
+	 */
+	@Deprecated
+	public void setFadeTarget(byte fadeTarget) {
+		fadeIn.setFadeTarget(fadeTarget);
+		CallUpdate("fadeTarget", fadeTarget);
+	}
+
+	/**
+	 * Gets the starting volume for the fade
+	 * @return
+	 * @deprecated returns fadeIn value
+	 */
+	@Deprecated
+	public byte getFadeStart() {
+		return fadeIn.getFadeStart();
+	}
+
+	/**
+	 * Sets the starting volume for the fade
+	 * @param fadeStart
+	 * @deprecated set fadeIn value
+	 */
+	@Deprecated
+	public void setFadeStart(byte fadeStart) {
+		fadeIn.setFadeStart(fadeStart);
+		CallUpdate("fadeStart", fadeStart);
+	}
+
+	/**
+	 * Gets the duration of the fade
+	 * @return duration of the fade
+	 * @deprecated returns fadeIn value
+	 */
+	@Deprecated
+	public int getFadeDuration() {
+		return fadeIn.getFadeDuration();
+	}
+
+	/**
+	 * Sets the duration of the fade
+	 * @param fadeDuration
+	 * @deprecated set fadeIn value
+	 */
+	@Deprecated
+	public void setFadeDuration(int fadeDuration) {
+		fadeIn.setFadeDuration(fadeDuration);
+		CallUpdate("fadeDuration", fadeDuration);
+	}
+
+	/**
+	 * Gets the tick when fade will be finished
+	 * @return tick
+	 * @deprecated returns fadeIn value
+	 */
+	@Deprecated
+	public int getFadeDone() {
+		return fadeIn.getFadeDone();
+	}
+
+	/**
+	 * Sets the tick when fade will be finished
+	 *
+	 * @param fadeDone
+	 * @deprecated set fadeIn value
+	 */
+	@Deprecated
+	public void setFadeDone(int fadeDone) {
+		fadeIn.setFadeDone(fadeDone);
+		CallUpdate("fadeDone", fadeDone);
+	}
+
+	/**
+	 * Check if 6 octave range is enabled
+	 *
+	 * @return true if enabled, false otherwise
+	 */
+	public boolean isEnable10Octave() {
+		return enable10Octave;
+	}
+
+	/**
+	 * Enable or disable 6 octave range
+	 * <p>
+	 * If not enabled, notes will be transposed to 2 octave range
+	 *
+	 * @param enable10Octave true if enabled, false otherwise
+	 */
+	public void setEnable10Octave(boolean enable10Octave) {
+		this.enable10Octave = enable10Octave;
+	}
+
+	/**
+	 * Starts this SongPlayer
+	 */
+	private void start() {
+		plugin.doAsync(() -> {
+			while (!destroyed) {
+				long startTime = System.currentTimeMillis();
+				lock.lock();
+				try {
+					if (destroyed || NoteBlockAPI.getAPI().isDisabling()){
+						break;
+					}
+
+					if (playing || fading) {
+						if (fadeTemp != null){
+							if (fadeTemp.isDone()) {
+								fadeTemp = null;
+								fading = false;
+								if (!playing) {
+									SongStoppedEvent event = new SongStoppedEvent(this);
+									plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+									volume = fadeIn.getFadeTarget();
+									continue;
+								}
+							}else {
+								int fade = fadeTemp.calculateFade();
+								if (fade != -1){
+									volume = (byte) fade;
+								}
+							}
+						} else if (tick < fadeIn.getFadeDuration()){
+							int fade = fadeIn.calculateFade();
+							if (fade != -1){
+								volume = (byte) fade;
+							}
+							CallUpdate("fadeDone", fadeIn.getFadeDone());
+						} else if (tick >= song.getLength() - fadeOut.getFadeDuration()){
+							int fade = fadeOut.calculateFade();
+							if (fade != -1){
+								volume = (byte) fade;
+							}
+						}
+						
+						tick++;
+						if (tick > song.getLength()) {
+							tick = -1;
+							fadeIn.setFadeDone(0);
+							CallUpdate("fadeDone", fadeIn.getFadeDone());
+							fadeOut.setFadeDone(0);
+							volume = fadeIn.getFadeTarget();
+							if (repeat == RepeatMode.ONE){
+								SongLoopEvent event = new SongLoopEvent(this);
+								plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+
+								if (!event.isCancelled()) {
+									continue;
+								}
+							} else {
+								if (random) {
+									songQueue.put(song, true);
+									checkPlaylistQueue();
+									ArrayList<Song> left = new ArrayList<>();
+									for (Song s : songQueue.keySet()) {
+										if (!songQueue.get(s)) {
+											left.add(s);
+										}
+									}
+
+									if (left.size() == 0) {
+										left.addAll(songQueue.keySet());
+										for (Song s : songQueue.keySet()) {
+											songQueue.put(s, false);
+										}
+										song = left.get(rng.nextInt(left.size()));
+										actualSong = playlist.getIndex(song);
+										CallUpdate("song", song);
+										if (repeat == RepeatMode.ALL) {
+											SongLoopEvent event = new SongLoopEvent(this);
+											plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+
+											if (!event.isCancelled()) {
+												continue;
+											}
+										}
+									} else {
+										song = left.get(rng.nextInt(left.size()));
+										actualSong = playlist.getIndex(song);
+
+										CallUpdate("song", song);
+										SongNextEvent event = new SongNextEvent(this);
+										plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+										continue;
+									}
+								} else {
+									if (playlist.hasNext(actualSong)) {
+										actualSong++;
+										song = playlist.get(actualSong);
+										CallUpdate("song", song);
+										SongNextEvent event = new SongNextEvent(this);
+										plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+										continue;
+									} else {
+										actualSong = 0;
+										song = playlist.get(actualSong);
+										CallUpdate("song", song);
+										if (repeat == RepeatMode.ALL) {
+											SongLoopEvent event = new SongLoopEvent(this);
+											plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+
+											if (!event.isCancelled()) {
+												continue;
+											}
+										}
+									}
+								}
+							}
+							playing = false;
+							SongEndEvent event = new SongEndEvent(this);
+							plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+							if (autoDestroy) {
+								destroy();
+							}
+							continue;
+						}
+						CallUpdate("tick", tick);
+						
+						plugin.doSync(() -> {
+							try {
+								for (UUID uuid : playerList.keySet()) {
+									Player player = Bukkit.getPlayer(uuid);
+									if (player == null) {
+										// offline...
+										continue;
+									}
+									playTick(player, tick);
+								}
+							} catch (Exception e){
+								Bukkit.getLogger().severe("An error occurred during the playback of song "
+										+ (song != null ?
+										song.getPath() + " (" + song.getAuthor() + " - " + song.getTitle() + ")"
+										: "null"));
+								e.printStackTrace();
+							}
+						});
+					}
+				} catch (Exception e) {
+					Bukkit.getLogger().severe("An error occurred during the playback of song "
+							+ (song != null ?
+									song.getPath() + " (" + song.getAuthor() + " - " + song.getTitle() + ")"
+									: "null"));
+					e.printStackTrace();
+				} finally {
+					lock.unlock();
+				}
+
+				if (destroyed) {
+					break;
+				}
+
+				long duration = System.currentTimeMillis() - startTime;
+				float delayMillis = song.getDelay() * 50;
+				if (duration < delayMillis) {
+					try {
+						Thread.sleep((long) (delayMillis - duration));
+					} catch (InterruptedException e) {
+						// do nothing
+					}
+				}
+			}
+		});
+	}
+
+	private void checkPlaylistQueue(){
+		for (Song s : songQueue.keySet()){
+			if (!playlist.contains(s)){
+				songQueue.remove(s);
+			}
+		}
+
+		for (Song s : playlist.getSongList()){
+			if (!songQueue.containsKey(s)){
+				songQueue.put(s, false);
+			}
+		}
+	}
+	
+	/**
+	 * Returns {@link Fade} for Fade in effect
+	 * @return Fade
+	 */
+	public Fade getFadeIn(){
+		return fadeIn;
+	}
+	
+	/**
+	 * Returns {@link Fade} for Fade out effect
+	 * @return Fade
+	 */
+	public Fade getFadeOut(){
+		return fadeOut;
+	}
+	
+	/**
+	 * Gets list of current Player UUIDs listening to this SongPlayer
+	 * @return list of Player UUIDs
+	 */
+	public Set<UUID> getPlayerUUIDs() {
+		Set<UUID> uuids = new HashSet<>();
+		uuids.addAll(playerList.keySet());
+		return Collections.unmodifiableSet(uuids);
+	}
+
+	/**
+	 * Adds a Player to the list of Players listening to this SongPlayer
+	 * @param player
+	 */
+	public void addPlayer(Player player) {
+		addPlayer(player.getUniqueId());
+	}
+	
+	/**
+	 * Adds a Player to the list of Players listening to this SongPlayer
+	 * @param player's uuid
+	 */
+	public void addPlayer(UUID player) {
+		addPlayer(player, true);
+	}
+	
+	private void addPlayer(UUID player, boolean notify){
+		lock.lock();
+		try {
+			if (!playerList.containsKey(player)) {
+				playerList.put(player, false);
+				ArrayList<SongPlayer> songs = NoteBlockAPI.getSongPlayersByPlayer(player);
+				if (songs == null) {
+					songs = new ArrayList<SongPlayer>();
+				}
+				songs.add(this);
+				NoteBlockAPI.setSongPlayersByPlayer(player, songs);
+				if (notify){
+					Player p = Bukkit.getPlayer(player);
+					if (p != null){
+						CallUpdate("addplayer", p);
+					}
+				}
+			}
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Returns whether the SongPlayer is set to destroy itself when no one is listening 
+	 * or when the Song ends
+	 * @return if autoDestroy is enabled
+	 */
+	public boolean getAutoDestroy() {
+		lock.lock();
+		try {
+			return autoDestroy;
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Sets whether the SongPlayer is going to destroy itself when no one is listening 
+	 * or when the Song ends
+	 * @param autoDestroy if autoDestroy is enabled
+	 */
+	public void setAutoDestroy(boolean autoDestroy) {
+		lock.lock();
+		try {
+			this.autoDestroy = autoDestroy;
+			CallUpdate("autoDestroy", autoDestroy);
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Plays the Song for the specific player
+	 * @param player to play this SongPlayer for
+	 * @param tick to play at
+	 */
+	public abstract void playTick(Player player, int tick);
+
+	/**
+	 * SongPlayer will destroy itself
+	 */
+	public void destroy() {
+		lock.lock();
+		try {
+			SongDestroyingEvent event = new SongDestroyingEvent(this);
+			plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+			//Bukkit.getScheduler().cancelTask(threadId);
+			if (event.isCancelled()) {
+				return;
+			}
+			destroyed = true;
+			playing = false;
+			setTick((short) -1);
+			CallUpdate("destroyed", destroyed);
+			CallUpdate("playing", playing);
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Returns whether the SongPlayer is actively playing
+	 * @return is playing
+	 */
+	public boolean isPlaying() {
+		return playing;
+	}
+
+	/**
+	 * Sets whether the SongPlayer is playing
+	 * @param playing
+	 */
+	public void setPlaying(boolean playing) {
+		setPlaying(playing, null);
+	}
+
+	/**
+	 * Sets whether the SongPlayer is playing and whether it should fade if previous value was different
+	 * @param playing
+	 * @param fade
+	 */
+	public void setPlaying(boolean playing, boolean fade) {
+		setPlaying(playing, fade ? (playing ? fadeIn : fadeOut) : null);
+	}
+
+	public void setPlaying(boolean playing, Fade fade) {
+		if (this.playing == playing) return;
+
+		this.playing = playing;
+		if (fade != null && fade.getType() != FadeType.NONE) {
+			fadeTemp = new Fade(fade.getType(), fade.getFadeDuration());
+			fadeTemp.setFadeStart(playing ? 0 : volume);
+			fadeTemp.setFadeTarget(playing ? volume : 0);
+			fading = true;
+		} else {
+			fading = false;
+			fadeTemp = null;
+			volume = fadeIn.getFadeTarget();
+			if (!playing) {
+				SongStoppedEvent event = new SongStoppedEvent(this);
+				plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+			}
+		}
+
+		CallUpdate("playing", playing);
+	}
+
+	/**
+	 * Gets the current tick of this SongPlayer
+	 * @return
+	 */
+	public short getTick() {
+		return tick;
+	}
+
+	/**
+	 * Sets the current tick of this SongPlayer
+	 * @param tick
+	 */
+	public void setTick(short tick) {
+		this.tick = tick;
+		CallUpdate("tick", tick);
+	}
+
+	/**
+	 * Removes a player from this SongPlayer
+	 * @param player to remove
+	 */
+	public void removePlayer(Player player) {
+		removePlayer(player.getUniqueId());
+	}
+	
+	/**
+	 * Removes a player from this SongPlayer
+	 * @param uuid of player to remove
+	 */
+	public void removePlayer(UUID uuid) {
+		removePlayer(uuid, true);
+	}
+	
+	private void removePlayer(UUID player, boolean notify) {
+		lock.lock();
+		try {
+			if (notify){
+				Player p = Bukkit.getPlayer(player);
+				if (p != null){
+					CallUpdate("removeplayer", p);
+				}
+			}
+			playerList.remove(player);
+			if (NoteBlockAPI.getSongPlayersByPlayer(player) == null) {
+				return;
+			}
+			ArrayList<SongPlayer> songs = new ArrayList<>(
+					NoteBlockAPI.getSongPlayersByPlayer(player));
+			songs.remove(this);
+			NoteBlockAPI.setSongPlayersByPlayer(player, songs);
+			if (playerList.isEmpty() && autoDestroy) {
+				SongEndEvent event = new SongEndEvent(this);
+				plugin.doSync(() -> Bukkit.getPluginManager().callEvent(event));
+				destroy();
+			}
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Gets the current volume of this SongPlayer
+	 * @return volume (0-100)
+	 */
+	public byte getVolume() {
+		return volume;
+	}
+
+	/**
+	 * Sets the current volume of this SongPlayer
+	 * @param volume (0-100)
+	 */
+	public void setVolume(byte volume) {
+		if (volume > 100){
+			volume = 100;
+		} else if (volume < 0){
+			volume = 0;
+		}
+		this.volume = volume;
+		
+		fadeIn.setFadeTarget(volume);
+		fadeOut.setFadeStart(volume);
+		if (fadeTemp != null) {
+			if (playing) fadeTemp.setFadeTarget(volume);
+			else fadeTemp.setFadeStart(volume);
+		}
+		
+		CallUpdate("volume", volume);
+	}
+
+	/**
+	 * Gets the Song being played by this SongPlayer
+	 * @return
+	 */
+	public Song getSong() {
+		return song;
+	}
+	
+	/**
+	 * Gets the Playlist being played by this SongPlayer
+	 * @return
+	 */
+	public Playlist getPlaylist() {
+		return playlist;
+	}
+	
+	/**
+	 * Sets the Playlist being played by this SongPlayer. Will affect next Song
+	 */
+	public void setPlaylist(Playlist playlist) {
+		this.playlist = playlist;
+	}
+	
+	/**
+	 * Get index of actually played {@link Song} in {@link Playlist}
+	 * @return
+	 */
+	public int getPlayedSongIndex(){
+		return actualSong;
+	}
+	
+	/**
+	 * Start playing {@link Song} at specified index in {@link Playlist}
+	 * If there is no {@link Song} at this index, {@link SongPlayer} will continue playing current song
+	 * @param index
+	 */
+	public void playSong(int index){
+		lock.lock();
+		try {
+			if (playlist.exist(index)){
+				song = playlist.get(index);
+				actualSong = index;
+				tick = -1;
+				fadeIn.setFadeDone(0);
+				fadeOut.setFadeDone(0);
+				CallUpdate("song", song);
+				CallUpdate("fadeDone", fadeIn.getFadeDone());
+				CallUpdate("tick", tick);
+			}
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Start playing {@link Song} that is next in {@link Playlist} or random {@link Song} from {@link Playlist}
+	 */
+	public void playNextSong(){
+		lock.lock();
+		try {
+			tick = song.getLength();
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Gets the SoundCategory of this SongPlayer
+	 * @see SoundCategory
+	 * @return SoundCategory of this SongPlayer
+	 */
+	public SoundCategory getCategory() {
+		return soundCategory;
+	}
+
+	/**
+	 * Sets the SoundCategory for this SongPlayer
+	 * @param soundCategory
+	 */
+	public void setCategory(SoundCategory soundCategory) {
+		this.soundCategory = soundCategory;
+		CallUpdate("soundCategory", soundCategory.name());
+	}
+	
+	/**
+	 * Sets whether the SongPlayer will loop
+	 * @deprecated
+	 * @param loop
+	 */
+	public void setLoop(boolean loop){
+		this.repeat = RepeatMode.ALL;
+	}
+	
+	/**
+	 * Gets whether the SongPlayer will loop
+	 * @deprecated
+	 * @return is loop
+	 */
+	public boolean isLoop(){
+		return repeat == RepeatMode.ALL;
+	}
+
+	/**
+	 * Sets SongPlayer's {@link RepeatMode}
+	 * @param repeatMode
+	 */
+	public void setRepeatMode(RepeatMode repeatMode){
+		this.repeat = repeatMode;
+	}
+
+	/**
+	 * Gets SongPlayer's {@link RepeatMode}
+	 * @return
+	 */
+	public RepeatMode getRepeatMode(){
+		return repeat;
+	}
+
+	/**
+	 * Sets whether the SongPlayer will choose next song from player randomly
+	 * @param random
+	 */
+	public void setRandom(boolean random){
+		this.random = random;
+	}
+
+	/**
+	 * Gets whether the SongPlayer will choose next song from player randomly
+	 * @return is random
+	 */
+	public boolean isRandom(){
+		return random;
+	}
+
+	public ChannelMode getChannelMode(){
+		return channelMode;
+	}
+
+	void CallUpdate(String key, Object value){
+		if (oldSongPlayer == null){
+			return;
+		}
+		try {
+			Method m = com.xxmicloxx.NoteBlockAPI.SongPlayer.class.getDeclaredMethod("update", String.class, Object.class);
+			m.setAccessible(true);
+			m.invoke(oldSongPlayer, key, value);
+		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException
+				| SecurityException e) {
+			e.printStackTrace();
+		}
+	}
+	
+	void makeNewClone(Class newClass){
+		try {
+			Constructor c = newClass.getDeclaredConstructor(new Class[] { SongPlayer.class });
+			c.setAccessible(true);
+			oldSongPlayer = (com.xxmicloxx.NoteBlockAPI.SongPlayer) c.newInstance(new Object[]{this});
+		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
+				| NoSuchMethodException | SecurityException e) {
+			e.printStackTrace();
+		}
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/CompatibilityUtils.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/CompatibilityUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..155d203dbd09c1aee97bf1a570f66c68018146ff
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/CompatibilityUtils.java
@@ -0,0 +1,309 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import com.xxmicloxx.NoteBlockAPI.model.CustomInstrument;
+import com.xxmicloxx.NoteBlockAPI.model.SoundCategory;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.Sound;
+import org.bukkit.entity.Player;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+/**
+ * Fields/methods for reflection &amp; version checking
+ */
+public class CompatibilityUtils {
+
+	public static final String OBC_DIR = Bukkit.getServer().getClass().getPackage().getName();
+	public static final String NMS_DIR = OBC_DIR.replaceFirst("org.bukkit.craftbukkit", "net.minecraft.server");
+
+	private static Class<? extends Enum> soundCategoryClass;
+	private static HashMap<String, Method> playSoundMethod = new HashMap<>();
+
+	private static float serverVersion = -1;
+
+	/**
+	 * Gets NMS class from given name
+	 * @param name of class (w/ package)
+	 * @return Class of given name
+	 */
+	public static Class<?> getMinecraftClass(String name) {
+		try {
+			return Class.forName(NMS_DIR + "." + name);
+		} catch (ClassNotFoundException e) {
+			e.printStackTrace();
+			return null;
+		}
+	}
+
+	/**
+	 * Gets CraftBukkit class from given name
+	 * @param name of class (w/ package)
+	 * @return Class of given name
+	 */
+	public static Class<?> getCraftBukkitClass(String name) {
+		try {
+			return Class.forName(OBC_DIR + "." + name);
+		} catch (ClassNotFoundException e) {
+			e.printStackTrace();
+			return null;
+		}
+	}
+
+	private static Class<? extends Enum> getSoundCategoryClass() throws ClassNotFoundException {
+		if (isSoundCategoryCompatible() && soundCategoryClass == null){
+			soundCategoryClass = (Class<? extends Enum>) Class.forName("org.bukkit.SoundCategory");
+		}
+		return soundCategoryClass;
+	}
+
+	private static Method getPlaySoundMethod(Class<?> sound, boolean soundCategory)
+			throws ClassNotFoundException, NoSuchMethodException {
+		String cacheKey = sound.getName() + soundCategory;
+		Method method = playSoundMethod.get(cacheKey);
+
+		if (method == null) {
+			//determine whether sound is an enum (pre 1.21.3) or an interface (post 1.21.3)
+			Class<?> soundParameter = getSoundParameterClass(sound);
+
+			if (soundCategory) {
+				method = Player.class.getMethod("playSound", Location.class, soundParameter,
+						getSoundCategoryClass(), float.class, float.class);
+			} else {
+				method = Player.class.getMethod("playSound", Location.class, soundParameter,
+						float.class, float.class);
+			}
+
+			playSoundMethod.put(cacheKey, method);
+		}
+		return method;
+	}
+
+	private static Class<?> getSoundParameterClass(Class<?> sound) {
+		return Sound.class.isAssignableFrom(sound) ? Sound.class : sound;
+	}
+
+	/**
+	 * Returns whether the version of Bukkit is or is after 1.12
+	 * @return version is after 1.12
+	 * @deprecated Compare {@link #getServerVersion()} with 0.0112f
+	 */
+	public static boolean isPost1_12() {
+		return getServerVersion() >= 0.0112f;
+	}
+
+	/**
+	 * Returns if SoundCategory is able to be used
+	 * @see org.bukkit.SoundCategory
+	 * @see SoundCategory
+	 * @return can use SoundCategory
+	 */
+	protected static boolean isSoundCategoryCompatible() {
+		return getServerVersion() >= 0.0111f;
+	}
+	
+	/**
+	 * Plays a sound using NMS &amp; reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 * 
+	 * @deprecated use {@link #playSound(Player, Location, String, SoundCategory, float, float, float)}
+	 */
+	public static void playSound(Player player, Location location, String sound, 
+			SoundCategory category, float volume, float pitch) {
+		playSound(player, location, sound, category, volume, pitch, 0);
+	}
+
+	/**
+	 * Plays a sound using NMS &amp; reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 * @deprecated use {@link #playSound(Player, Location, String, SoundCategory, float, float, float)}
+	 */
+	public static void playSound(Player player, Location location, String sound, 
+			SoundCategory category, float volume, float pitch, boolean stereo) {
+		playSound(player, location, sound, category, volume, pitch, stereo ? 2 : 0);
+	}
+
+	/**
+	 * Plays a sound using NMS &amp; reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 * 
+	 * @deprecated use {@link #playSound(Player, Location, Sound, SoundCategory, float, float, float)}
+	 */
+	public static void playSound(Player player, Location location, Sound sound, 
+			SoundCategory category, float volume, float pitch) {
+		playSound(player, location, sound, category, volume, pitch, 0);
+	}
+	
+	/**
+	 * Plays a sound using NMS &amp; reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 * @deprecated use {@link #playSound(Player, Location, Sound, SoundCategory, float, float, float)}
+	 */
+	public static void playSound(Player player, Location location, Sound sound, 
+			SoundCategory category, float volume, float pitch, boolean stereo) {
+		playSound(player, location, sound, category, volume, pitch, stereo ? 2 : 0);
+	}
+
+	/**
+	 * Plays a sound using NMS &amp; reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 * @param distance
+	 */
+	public static void playSound(Player player, Location location, String sound,
+								 SoundCategory category, float volume, float pitch, float distance) {
+		playSoundUniversal(player, location, sound, category, volume, pitch, distance);
+	}
+
+	/**
+	 * Plays a sound using NMS &amp; reflection
+	 * @param player
+	 * @param location
+	 * @param sound
+	 * @param category
+	 * @param volume
+	 * @param pitch
+	 * @param distance
+	 */
+	public static void playSound(Player player, Location location, Sound sound,
+								 SoundCategory category, float volume, float pitch, float distance) {
+		playSoundUniversal(player, location, sound, category, volume, pitch, distance);
+	}
+
+	private static void playSoundUniversal(Player player, Location location, Object sound,
+								 SoundCategory category, float volume, float pitch, float distance) {
+		try {
+			if (isSoundCategoryCompatible()) {
+				Method method = getPlaySoundMethod(sound.getClass(), true);
+				Enum<?> soundCategoryEnum = Enum.valueOf(getSoundCategoryClass(), category.name());
+				method.invoke(player, MathUtils.stereoPan(location, distance), sound, soundCategoryEnum, volume, pitch);
+			} else {
+				Method method = getPlaySoundMethod(sound.getClass(), false);
+				method.invoke(player, MathUtils.stereoPan(location, distance), sound, volume, pitch);
+			}
+		} catch (NoSuchMethodException | ClassNotFoundException | IllegalAccessException | InvocationTargetException e) {
+			e.printStackTrace();
+		}
+	}
+
+	/**
+	 * Gets instruments which were added post-1.12
+	 * @return ArrayList of instruments
+	 * @deprecated Use {@link #getVersionCustomInstruments(float)}
+	 */
+	public static ArrayList<CustomInstrument> get1_12Instruments(){
+		return getVersionCustomInstruments(0.0112f);
+	}
+
+	/**
+	 * Return list of instuments which were added in specified version
+	 * @param serverVersion 1.12 = 0.0112f, 1.14 = 0.0114f,...
+	 * @return list of custom instruments, if no instuments were added in specified version returns empty list
+	 */
+	public static ArrayList<CustomInstrument> getVersionCustomInstruments(float serverVersion){
+		ArrayList<CustomInstrument> instruments = new ArrayList<>();
+		if (serverVersion == 0.0112f){
+			instruments.add(new CustomInstrument((byte) 0, "Guitar", "block.note_block.guitar.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Flute", "block.note_block.flute.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Bell", "block.note_block.bell.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Chime", "block.note_block.icechime.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Xylophone", "block.note_block.xylobone.ogg"));
+			return instruments;
+		}
+
+		if (serverVersion == 0.0114f){
+			instruments.add(new CustomInstrument((byte) 0, "Iron Xylophone", "block.note_block.iron_xylophone.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Cow Bell", "block.note_block.cow_bell.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Didgeridoo", "block.note_block.didgeridoo.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Bit", "block.note_block.bit.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Banjo", "block.note_block.banjo.ogg"));
+			instruments.add(new CustomInstrument((byte) 0, "Pling", "block.note_block.pling.ogg"));
+			return instruments;
+		}
+		return instruments;
+	}
+
+	/**
+	 * Return list of custom instruments based on song first custom instrument index and server version
+	 * @param firstCustomInstrumentIndex
+	 * @return
+	 */
+	public static ArrayList<CustomInstrument> getVersionCustomInstrumentsForSong(int firstCustomInstrumentIndex){
+		ArrayList<CustomInstrument> instruments = new ArrayList<>();
+
+		if (getServerVersion() < 0.0112f){
+			if (firstCustomInstrumentIndex == 10) {
+				instruments.addAll(getVersionCustomInstruments(0.0112f));
+			} else if (firstCustomInstrumentIndex == 16){
+				instruments.addAll(getVersionCustomInstruments(0.0112f));
+				instruments.addAll(getVersionCustomInstruments(0.0114f));
+			}
+		} else if (getServerVersion() < 0.0114f){
+			if (firstCustomInstrumentIndex == 16){
+				instruments.addAll(getVersionCustomInstruments(0.0114f));
+			}
+		}
+
+		return instruments;
+	}
+
+	/**
+	 * Returns server version as float less than 1 with two digits for each version part
+	 * @return e.g. 0.011401f for 1.14.1
+	 */
+	public static float getServerVersion(){
+		if (serverVersion != -1){
+			return serverVersion;
+		}
+
+		String versionInfo = Bukkit.getServer().getVersion();
+		int start = versionInfo.lastIndexOf('(');
+		int end = versionInfo.lastIndexOf(')');
+
+		String[] versionParts = versionInfo.substring(start + 5, end).split("\\.");
+
+		String versionString = "0.";
+		for (String part : versionParts){
+			if (part.length() == 1){
+				versionString += "0";
+			}
+
+			versionString += part;
+		}
+		serverVersion = Float.parseFloat(versionString);
+		return serverVersion;
+	}
+
+	public static Material getNoteBlockMaterial(){
+		return Material.valueOf("NOTE_BLOCK");
+	}
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/InstrumentUtils.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/InstrumentUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ca73be379d750cb43a61c64b619c5b20813a22c
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/InstrumentUtils.java
@@ -0,0 +1,233 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import com.xxmicloxx.NoteBlockAPI.model.Sound;
+import org.bukkit.Instrument;
+
+/**
+ * Various methods for working with instruments
+ */
+public class InstrumentUtils {
+
+	/**
+	 * Returns the org.bukkit.Sound enum for the current server version
+	 *
+	 * @param instrument
+	 * @return Sound enum (for the current server version)
+	 * @see Sound
+	 */
+	public static org.bukkit.Sound getInstrument(byte instrument) {
+		return Sound.getFromBukkitName(getInstrumentName(instrument));
+	}
+
+	/**
+	 * Add suffix to vanilla instrument to use sound outside 2 octave range
+	 * @param instrument instrument id
+	 * @param key sound key
+	 * @param pitch
+	 * @return warped name
+	 */
+	public static String warpNameOutOfRange(byte instrument, byte key, short pitch) {
+		return warpNameOutOfRange(getSoundNameByInstrument(instrument), key, pitch);
+	}
+
+	/**
+	 * Add suffix to qualified name to use sound outside 2 octave range
+	 *
+	 * @param name qualified name
+	 * @param key sound key
+	 * @param pitch
+	 * @return warped name
+	 */
+	public static String warpNameOutOfRange(String name, byte key, short pitch) {
+		key = NoteUtils.applyPitchToKey(key, pitch);
+		// -15 base_-2
+		// 9 base_-1
+		// 33 base
+		// 57 base_1
+		// 81 base_2
+		// 105 base_3
+		if(key < 9) name += "_-2";
+		else if(key < 33) name += "_-1";
+		else //noinspection StatementWithEmptyBody
+			if(key < 57);
+		else if(key < 81) name += "_1";
+		else if(key < 105) name += "_2";
+		return name;
+	}
+
+	/**
+	 * Returns the name of vanilla instrument
+	 *
+	 * @param instrument instrument identifier
+	 * @return Sound name with full qualified name
+	 */
+	public static String getSoundNameByInstrument(byte instrument) {
+		//noinspection RedundantSuppression
+		switch (instrument) {
+			case 0:
+				//noinspection DuplicateBranchesInSwitch
+				return "minecraft:block.note_block.harp";
+			case 1:
+				return "minecraft:block.note_block.bass";
+			case 2:
+				//noinspection SpellCheckingInspection
+				return "minecraft:block.note_block.basedrum";
+			case 3:
+				return "minecraft:block.note_block.snare";
+			case 4:
+				return "minecraft:block.note_block.hat";
+			case 5:
+				return "minecraft:block.note_block.guitar";
+			case 6:
+				return "minecraft:block.note_block.flute";
+			case 7:
+				return "minecraft:block.note_block.bell";
+			case 8:
+				return "minecraft:block.note_block.chime";
+			case 9:
+				return "minecraft:block.note_block.xylophone";
+			case 10:
+				return "minecraft:block.note_block.iron_xylophone";
+			case 11:
+				return "minecraft:block.note_block.cow_bell";
+			case 12:
+				return "minecraft:block.note_block.didgeridoo";
+			case 13:
+				return "minecraft:block.note_block.bit";
+			case 14:
+				return "minecraft:block.note_block.banjo";
+			case 15:
+				//noinspection SpellCheckingInspection
+				return "minecraft:block.note_block.pling";
+			default:
+				return "minecraft:block.note_block.harp";
+		}
+	}
+
+	/**
+	 * Returns the name of the org.bukkit.Sound enum for the current server version
+	 *
+	 * @param instrument
+	 * @return Sound enum name (for the current server version)
+	 * @see Sound
+	 */
+	public static String getInstrumentName(byte instrument) {
+		switch (instrument) {
+			case 0:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_HARP").name();
+			case 1:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_BASS").name();
+			case 2:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_BASEDRUM").name();
+			case 3:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_SNARE").name();
+			case 4:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_HAT").name();
+			case 5:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_GUITAR").name();
+			case 6:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_FLUTE").name();
+			case 7:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_BELL").name();
+			case 8:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_CHIME").name();
+			case 9:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_XYLOPHONE").name();
+			case 10:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_IRON_XYLOPHONE").name();
+			case 11:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_COW_BELL").name();
+			case 12:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_DIDGERIDOO").name();
+			case 13:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_BIT").name();
+			case 14:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_BANJO").name();
+			case 15:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_PLING").name();
+			default:
+				return Sound.getFromBukkitName("BLOCK_NOTE_BLOCK_HARP").name();
+		}
+}
+
+	/**
+	 * Returns the name of the org.bukkit.Instrument enum for the current server version
+	 * @param instrument
+	 * @return Instrument enum (for the current server version)
+	 */
+	public static Instrument getBukkitInstrument(byte instrument) {
+		switch (instrument) {
+			case 0:
+				return Instrument.PIANO;
+			case 1:
+				return Instrument.BASS_GUITAR;
+			case 2:
+				return Instrument.BASS_DRUM;
+			case 3:
+				return Instrument.SNARE_DRUM;
+			case 4:
+				return Instrument.STICKS;
+			default: {
+				if (CompatibilityUtils.getServerVersion() >= 0.0112f) {
+					switch (instrument) {
+						case 5:
+							return Instrument.valueOf("GUITAR");
+						case 6:
+							return Instrument.valueOf("FLUTE");
+						case 7:
+							return Instrument.valueOf("BELL");
+						case 8:
+							return Instrument.valueOf("CHIME");
+						case 9:
+							return Instrument.valueOf("XYLOPHONE");
+						default: {
+							if (CompatibilityUtils.getServerVersion() >= 0.0114f) {
+								switch (instrument) {
+									case 10:
+										return Instrument.valueOf("IRON_XYLOPHONE");
+									case 11:
+										return Instrument.valueOf("COW_BELL");
+									case 12:
+										return Instrument.valueOf("DIDGERIDOO");
+									case 13:
+										return Instrument.valueOf("BIT");
+									case 14:
+										return Instrument.valueOf("BANJO");
+									case 15:
+										return Instrument.valueOf("PLING");
+								}
+							}
+							return Instrument.PIANO;
+						}
+					}
+				}
+				return Instrument.PIANO;
+			}
+		}
+	}
+
+	/**
+	 * If true, the byte given represents a custom instrument
+	 * @param instrument
+	 * @return whether the byte represents a custom instrument
+	 */
+	public static boolean isCustomInstrument(byte instrument) {
+		return instrument >= getCustomInstrumentFirstIndex();
+	}
+
+	/**
+	 * Gets the first index in which a custom instrument 
+	 * can be added to the existing list of instruments
+	 * @return index where an instrument can be added
+	 */
+	public static byte getCustomInstrumentFirstIndex() {
+		if (CompatibilityUtils.getServerVersion() >= 0.0114f) {
+			return 16;
+		}
+		if (CompatibilityUtils.getServerVersion() >= 0.0112f) {
+			return 10;
+		}
+		return 5;
+	}
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/Interpolator.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/Interpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..55889ab77b74649264938a4596d249ae64d98c6b
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/Interpolator.java
@@ -0,0 +1,101 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import java.util.Arrays;
+
+/**
+ * <p>Static methods for doing useful math</p><hr>
+ *
+ * @author : $Author: brian $
+ * @version : $Revision: 1.1 $
+ *          <hr><p><a href="http://www.mbari.org">
+ *          The Monterey Bay Aquarium Research Institute (MBARI)</a> provides this
+ *          documentation and code &quot;as is&quot;, with no warranty, express or
+ *          implied, of its quality or consistency. It is provided without support and
+ *          without obligation on the part of MBARI to assist in its use, correction,
+ *          modification, or enhancement. This information should not be published or
+ *          distributed to third parties without specific written permission from
+ *          MBARI.</p><br>
+ *          Copyright 2002 MBARI.<br>
+ *          MBARI Proprietary Information. All rights reserved.<br><hr><br>
+ */
+public class Interpolator {
+
+	public static double[] interpLinear(double[] x, double[] y, double[] xi) throws IllegalArgumentException {
+		if (x.length != y.length) {
+			throw new IllegalArgumentException("X and Y must be the same length");
+		}
+		if (x.length == 1) {
+			throw new IllegalArgumentException("X must contain more than one value");
+		}
+
+		double[] dx = new double[x.length - 1];
+		double[] dy = new double[x.length - 1];
+		double[] slope = new double[x.length - 1];
+		double[] intercept = new double[x.length - 1];
+
+		// Calculate the line equation (i.e. slope and intercept) between each point
+		for (int i = 0; i < x.length - 1; i++) {
+			dx[i] = x[i + 1] - x[i];
+			if (dx[i] == 0) {
+				throw new IllegalArgumentException("X must be montotonic. A duplicate " + "x-value was found");
+			}
+			if (dx[i] < 0) {
+				throw new IllegalArgumentException("X must be sorted");
+			}
+			dy[i] = y[i + 1] - y[i];
+			slope[i] = dy[i] / dx[i];
+			intercept[i] = y[i] - x[i] * slope[i];
+		}
+
+		// Perform the interpolation here
+		double[] yi = new double[xi.length];
+		for (int i = 0; i < xi.length; i++) {
+			if ((xi[i] > x[x.length - 1]) || (xi[i] < x[0])) {
+				yi[i] = Double.NaN;
+			} else {
+				int loc = Arrays.binarySearch(x, xi[i]);
+				if (loc < -1) {
+					loc = -loc - 2;
+					yi[i] = slope[loc] * xi[i] + intercept[loc];
+				} else {
+					yi[i] = y[loc];
+				}
+			}
+		}
+
+		return yi;
+	}
+
+	public static double[] interpLinear(long[] x, double[] y, long[] xi) throws IllegalArgumentException {
+		double[] xd = new double[x.length];
+		for (int i = 0; i < x.length; i++) {
+			xd[i] = (double) x[i];
+		}
+
+		double[] xid = new double[xi.length];
+		for (int i = 0; i < xi.length; i++) {
+			xid[i] = (double) xi[i];
+		}
+
+		return interpLinear(xd, y, xid);
+	}
+
+	public static double interpLinear(double[] xy, double xx) {
+		if (xy.length % 2 != 0) {
+			throw new IllegalArgumentException("XY must be divisible by two.");
+		}
+
+		double[] x = new double[xy.length/2];
+		double[] y = new double[x.length];
+
+		for (int i = 0; i < xy.length; i++) {
+			if (i % 2 == 0) {
+				x[i/2] = xy[i];
+			} else {
+				y[i/2] = xy[i];
+			}
+		}
+		return interpLinear(x, y, new double[] {xx})[0];
+	}
+	
+}
\ No newline at end of file
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/MathUtils.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/MathUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0e9178e94a92e1e0023c382c1c7e75d69eddf5b
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/MathUtils.java
@@ -0,0 +1,51 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import org.bukkit.Location;
+
+public class MathUtils {
+
+	private static double[] cos = new double[360];
+	private static double[] sin = new double[360];
+
+	static {
+		for (int deg = 0; deg < 360; deg++) {
+			cos[deg] = Math.cos(Math.toRadians(deg));
+			sin[deg] = Math.sin(Math.toRadians(deg));
+		}
+	}
+	
+	private static double[] getCos(){
+		return cos;
+	}
+	
+	private static double[] getSin(){
+		return sin;
+	}
+	
+	public static Location stereoSourceLeft(Location location, float distance) {
+		int angle = getAngle(location.getYaw());
+	    return location.clone().add(-getCos()[angle] * distance, 0, -getSin()[angle] * distance);
+	}
+	public static Location stereoSourceRight(Location location, float distance) {
+		int angle = getAngle(location.getYaw());
+	    return location.clone().add(getCos()[angle] * distance, 0, getSin()[angle] * distance);
+	}
+
+	/**
+	 * Calculate new location for stereo
+	 * @param location origin location
+	 * @param distance negative for left side, positive for right side
+	 * @return
+	 */
+	public static Location stereoPan(Location location, float distance){
+		int angle = getAngle(location.getYaw());
+		return location.clone().add( getCos()[angle] * distance, 0, getSin()[angle] * distance);
+	}
+
+	private static int getAngle(float yaw){
+		int angle = (int) yaw;
+		while (angle < 0) angle += 360;
+		return angle % 360;
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/NBSDecoder.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/NBSDecoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b74668337eec59cc4c489d9660870411a391b51
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/NBSDecoder.java
@@ -0,0 +1,240 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import com.xxmicloxx.NoteBlockAPI.model.CustomInstrument;
+import com.xxmicloxx.NoteBlockAPI.model.Layer;
+import com.xxmicloxx.NoteBlockAPI.model.Note;
+import com.xxmicloxx.NoteBlockAPI.model.Song;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+/**
+ * Utils for reading Note Block Studio data
+ *
+ */
+public class NBSDecoder {
+
+	/**
+	 * Parses a Song from a Note Block Studio project file (.nbs)
+	 * @see Song
+	 * @param songFile .nbs file
+	 * @return Song object representing a Note Block Studio project
+	 */
+	public static Song parse(File songFile) {
+		try {
+			return parse(new FileInputStream(songFile), songFile);
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	/**
+	 * Parses a Song from an InputStream
+	 * @see Song
+	 * @param inputStream of a Note Block Studio project file (.nbs)
+	 * @return Song object from the InputStream
+	 */
+	public static Song parse(InputStream inputStream) {
+		return parse(inputStream, null); // Source is unknown -> no file
+	}
+
+	/**
+	 * Parses a Song from an InputStream and a Note Block Studio project file (.nbs)
+	 * @see Song
+	 * @param inputStream of a .nbs file
+	 * @param songFile representing a .nbs file
+	 * @return Song object representing the given .nbs file
+	 */
+	private static Song parse(InputStream inputStream, File songFile) {
+		HashMap<Integer, Layer> layerHashMap = new HashMap<Integer, Layer>();
+		byte biggestInstrumentIndex = -1;
+		boolean isStereo = false;
+		try {
+			DataInputStream dataInputStream = new DataInputStream(inputStream);
+			short length = readShort(dataInputStream);
+			int firstcustominstrument = 10; //Backward compatibility - most of songs with old structure are from 1.12
+			int firstcustominstrumentdiff;
+			int nbsversion = 0;
+			if (length == 0) {
+				nbsversion = dataInputStream.readByte();
+				firstcustominstrument = dataInputStream.readByte();
+				if (nbsversion >= 3) {
+					length = readShort(dataInputStream);
+				}
+			}
+			firstcustominstrumentdiff = InstrumentUtils.getCustomInstrumentFirstIndex() - firstcustominstrument;
+			short songHeight = readShort(dataInputStream);
+			String title = readString(dataInputStream);
+			String author = readString(dataInputStream);
+			String originalAuthor = readString(dataInputStream); // original author
+			String description = readString(dataInputStream);
+			float speed = readShort(dataInputStream) / 100f;
+			dataInputStream.readBoolean(); // auto-save
+			dataInputStream.readByte(); // auto-save duration
+			dataInputStream.readByte(); // x/4ths, time signature
+			readInt(dataInputStream); // minutes spent on project
+			readInt(dataInputStream); // left clicks (why?)
+			readInt(dataInputStream); // right clicks (why?)
+			readInt(dataInputStream); // blocks added
+			readInt(dataInputStream); // blocks removed
+			readString(dataInputStream); // .mid/.schematic file name
+			if (nbsversion >= 4) {
+				dataInputStream.readByte(); // loop on/off
+				dataInputStream.readByte(); // max loop count
+				readShort(dataInputStream); // loop start tick
+			}
+			short tick = -1;
+			while (true) {
+				short jumpTicks = readShort(dataInputStream); // jumps till next tick
+				//System.out.println("Jumps to next tick: " + jumpTicks);
+				if (jumpTicks == 0) {
+					break;
+				}
+				tick += jumpTicks;
+				//System.out.println("Tick: " + tick);
+				short layer = -1;
+				while (true) {
+					short jumpLayers = readShort(dataInputStream); // jumps till next layer
+					if (jumpLayers == 0) {
+						break;
+					}
+					layer += jumpLayers;
+					//System.out.println("Layer: " + layer);
+					byte instrument = dataInputStream.readByte();
+
+					if (firstcustominstrumentdiff > 0 && instrument >= firstcustominstrument){
+						instrument += firstcustominstrumentdiff;
+					}
+
+					byte key = dataInputStream.readByte();
+					byte velocity = 100;
+					int panning = 100;
+					short pitch = 0;
+					if (nbsversion >= 4) {
+						velocity = dataInputStream.readByte(); // note block velocity
+						panning = 200 - dataInputStream.readUnsignedByte(); // note panning, 0 is right in nbs format
+						pitch = readShort(dataInputStream); // note block pitch
+					}
+
+					if (panning != 100){
+					    isStereo = true;
+                    }
+
+					setNote(layer, tick,
+							new Note(instrument /* instrument */, key/* note */, velocity, panning, pitch),
+							layerHashMap);
+				}
+			}
+
+			if (nbsversion > 0 && nbsversion < 3) {
+				length = tick;
+			}
+
+			for (int i = 0; i < songHeight; i++) {
+				Layer layer = layerHashMap.get(i);
+
+				String name = readString(dataInputStream);
+				if (nbsversion >= 4){
+					dataInputStream.readByte(); // layer lock
+				}
+
+				byte volume = dataInputStream.readByte();
+				int panning = 100;
+				if (nbsversion >= 2){
+					panning = 200 - dataInputStream.readUnsignedByte(); // layer stereo, 0 is right in nbs format
+				}
+
+                if (panning != 100){
+                    isStereo = true;
+                }
+
+				if (layer != null) {
+					layer.setName(name);
+					layer.setVolume(volume);
+					layer.setPanning(panning);
+				}
+			}
+			//count of custom instruments
+			byte customAmnt = dataInputStream.readByte();
+			CustomInstrument[] customInstrumentsArray = new CustomInstrument[customAmnt];
+
+			for (int index = 0; index < customAmnt; index++) {
+				customInstrumentsArray[index] = new CustomInstrument((byte) index, 
+						readString(dataInputStream), readString(dataInputStream));
+				dataInputStream.readByte();//pitch
+				dataInputStream.readByte();//key
+			}
+
+			if (firstcustominstrumentdiff < 0){
+				ArrayList<CustomInstrument> customInstruments = CompatibilityUtils.getVersionCustomInstrumentsForSong(firstcustominstrument);
+				customInstruments.addAll(Arrays.asList(customInstrumentsArray));
+				customInstrumentsArray = customInstruments.toArray(customInstrumentsArray);
+			} else {
+				firstcustominstrument += firstcustominstrumentdiff;
+			}
+
+			return new Song(speed, layerHashMap, songHeight, length, title, 
+					author, originalAuthor, description, songFile, firstcustominstrument, customInstrumentsArray, isStereo);
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} catch (EOFException e) {
+			String file = "";
+			if (songFile != null) {
+				file = songFile.getName();
+			}
+			Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.RED + "Song is corrupted: " + file);
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	/**
+	 * Sets a note at a tick in a song
+	 * @param layerIndex
+	 * @param ticks
+	 * @param note
+	 * @param layerHashMap
+	 */
+	private static void setNote(int layerIndex, int ticks, Note note, HashMap<Integer, Layer> layerHashMap) {
+		Layer layer = layerHashMap.get(layerIndex);
+		if (layer == null) {
+			layer = new Layer();
+			layerHashMap.put(layerIndex, layer);
+		}
+		layer.setNote(ticks, note);
+	}
+
+	private static short readShort(DataInputStream dataInputStream) throws IOException {
+		int byte1 = dataInputStream.readUnsignedByte();
+		int byte2 = dataInputStream.readUnsignedByte();
+		return (short) (byte1 + (byte2 << 8));
+	}
+
+	private static int readInt(DataInputStream dataInputStream) throws IOException {
+		int byte1 = dataInputStream.readUnsignedByte();
+		int byte2 = dataInputStream.readUnsignedByte();
+		int byte3 = dataInputStream.readUnsignedByte();
+		int byte4 = dataInputStream.readUnsignedByte();
+		return (byte1 + (byte2 << 8) + (byte3 << 16) + (byte4 << 24));
+	}
+
+	private static String readString(DataInputStream dataInputStream) throws IOException {
+		int length = readInt(dataInputStream);
+		StringBuilder builder = new StringBuilder(length);
+		for (; length > 0; --length) {
+			char c = (char) dataInputStream.readByte();
+			if (c == (char) 0x0D) {
+				c = ' ';
+			}
+			builder.append(c);
+		}
+		return builder.toString();
+	}
+	
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/NoteUtils.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/NoteUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..4b5994ec86cfb0058e6af6a8eee25c674306c2cf
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/NoteUtils.java
@@ -0,0 +1,112 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import com.xxmicloxx.NoteBlockAPI.model.Note;
+
+public class NoteUtils {
+
+    private static float[] pitches = null;
+
+    static {
+        pitches = new float[2401];
+
+        for (int i = 0; i < 2401; i++){
+            pitches[i] = (float) Math.pow(2, (i - 1200d) / 1200d);
+        }
+    }
+
+    @Deprecated
+    public static float getPitch(Note note){
+        return getPitch(note.getKey(), note.getPitch());
+    }
+
+    @Deprecated
+    public static float getPitch(byte key, short pitch){
+        return getPitchTransposed(key, pitch);
+    }
+
+    /**
+     * Get pitch in specific octave range
+     *
+     * @param note note
+     * @return pitch
+     */
+    public static float getPitchInOctave(Note note) {
+        return getPitchInOctave(note.getKey(), note.getPitch());
+    }
+
+    /**
+     * Get pitch in specific octave range
+     *
+     * @param key   sound key
+     * @param pitch extra pitch
+     * @return pitch
+     */
+    public static float getPitchInOctave(byte key, short pitch) {
+        // Apply pitch to key
+        key = applyPitchToKey(key, pitch);
+        pitch %= 100;
+
+        // -15 base_-2
+        // 9 base_-1
+        // 33 base
+        // 57 base_1
+        // 81 base_2
+        // 105 base_3
+        if(key < 9) key -= -15;
+        else if(key < 33) key -= 9;
+        else if(key < 57) key -= 33;
+        else if(key < 81) key -= 57;
+        else if(key < 105) key -= 81;
+
+        return pitches[key * 100 + pitch];
+    }
+
+    public static byte applyPitchToKey(byte key, short pitch) {
+        key += pitch / 100;
+        return key;
+    }
+
+    /**
+     * Get pitch after transposed
+     *
+     * @param note note
+     * @return pitch
+     */
+    public static float getPitchTransposed(Note note) {
+        return getPitchTransposed(note.getKey(), note.getPitch());
+    }
+
+    /**
+     * Get pitch after transposed
+     *
+     * @param key   sound key
+     * @param pitch extra pitch
+     * @return pitch
+     */
+    public static float getPitchTransposed(byte key, short pitch) {
+        // Apply key to pitch
+        pitch += key * 100;
+
+        while (pitch < 3300) pitch += 1200;
+        while (pitch > 5700) pitch -= 1200;
+
+        pitch -= 3300;
+
+        return pitches[pitch];
+    }
+
+    /**
+     * Returns true if combination of specified key and pitch is outside Minecraft octave range
+     * @param key
+     * @param pitch
+     * @return
+     */
+    public static boolean isOutOfRange(byte key, short pitch){
+        key = applyPitchToKey(key, pitch);
+
+        if(key < 33) return true;
+        else if(key < 57) return false;
+        else return true;
+    }
+
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/TimeUtils.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/TimeUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd72d54590a6f7f32dc8156e55aeff6f4b7276bc
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/TimeUtils.java
@@ -0,0 +1,80 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import com.xxmicloxx.NoteBlockAPI.songplayer.SongPlayer;
+
+public class TimeUtils {
+
+	/**
+	 * Returns {@link SongPlayer} song actual time in specified format
+	 * @param format use:
+	 * 		<ul>
+	 * 			<li>hh for two-digit hours</li>
+	 * 			<li>h for one-digit hours</li>
+	 * 			<li>mm for two-digit minutes</li>
+	 * 			<li>m for one-digit minutes</li>
+	 *			<li>ss for two-digit seconds</li>
+	 * 			<li>s for one-digit seconds</li>
+	 * 			<li>m for miliseconds (do not use without seconds, would be more than 4 digits)</li>
+	 * 		</ul>
+	 * @param songPlayer
+	 * @return formatted string
+	 */
+	public static String getActualTime(String format, SongPlayer songPlayer){
+		return getTime(format, songPlayer.getTick(), songPlayer.getSong().getSpeed());
+	}
+	
+	/**
+	 * Returns {@link SongPlayer} song length in specified format
+	 * @param format use:
+	 * 		<ul>
+	 * 			<li>hh for two-digit hours</li>
+	 * 			<li>h for one-digit hours</li>
+	 * 			<li>mm for two-digit minutes</li>
+	 * 			<li>m for one-digit minutes</li>
+	 *			<li>ss for two-digit seconds</li>
+	 * 			<li>s for one-digit seconds</li>
+	 * 			<li>m for miliseconds (do not use without seconds, would be more than 4 digits)</li>
+	 * 		</ul>
+	 * @param songPlayer
+	 * @return formatted string
+	 */
+	public static String getLength(String format, SongPlayer songPlayer){
+		return getTime(format, songPlayer.getSong().getLength(), songPlayer.getSong().getSpeed());
+	}
+	
+	private static String getTime(String format, short ticks, float speed){
+		String time = format;
+		long milisTotal = (long) ((ticks / speed) * 1000);
+		
+		int hours = 0;
+		if (time.contains("h")){
+			hours = (int) Math.floor(milisTotal / 1000 / 60 / 60);
+			milisTotal -= hours * 1000 * 60 * 60;
+		}
+		
+		int minutes = 0;
+		if (time.contains("m")){
+			minutes = (int) Math.floor(milisTotal / 1000 / 60);
+			milisTotal -= minutes * 1000 * 60;
+		}
+		
+		int seconds = 0;
+		if (time.contains("s")){
+			seconds = (int) Math.floor(milisTotal / 1000);
+			milisTotal -= seconds * 1000;
+		}
+		
+		time = time.replace("hh", String.format("%02", hours));
+		time = time.replace("h", hours + "");
+		
+		time = time.replace("mm", String.format("%02", minutes));
+		time = time.replace("m", minutes + "");
+		
+		time = time.replace("ss", String.format("%02", seconds));
+		time = time.replace("s", seconds + "");
+		
+		time = time.replace("n", milisTotal + "");
+		
+		return time;
+	}
+}
diff --git a/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/Updater.java b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/Updater.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d0c34b8e6facdef21c71c16036a994e66ad3663
--- /dev/null
+++ b/src/main/java/com/xxmicloxx/NoteBlockAPI/utils/Updater.java
@@ -0,0 +1,45 @@
+package com.xxmicloxx.NoteBlockAPI.utils;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+
+public class Updater {
+	
+	public static boolean checkUpdate(String resource, String actualVersion) throws MalformedURLException, IOException{
+		boolean snapshot = false;
+		if (actualVersion.contains("-SNAPSHOT")){
+			snapshot = true;
+			actualVersion = actualVersion.replace("-SNAPSHOT","");
+		}
+
+		Float version = getVersionNumber(actualVersion);
+		
+		URLConnection con = new URL("https://api.spigotmc.org/legacy/update.php?resource=" + resource).openConnection();
+		String newVersionString = new BufferedReader(new InputStreamReader(con.getInputStream())).readLine();
+		int first = newVersionString.indexOf("(");
+		String newVersion = first == -1 ? newVersionString : newVersionString.substring(0, first);
+
+		Float newVer = getVersionNumber(newVersion);
+
+		return snapshot ? newVer >= version : newVer > version;
+	}
+	
+	private static Float getVersionNumber(String version){
+		String[] versionParts = version.split("\\.");
+		String versionString = "0.";
+		
+		for (String vpart : versionParts){
+			if (vpart.length() < 2){
+				versionString += "0";
+			}
+			versionString += vpart;
+		}
+		
+		return Float.parseFloat(versionString);
+	}
+	
+}
